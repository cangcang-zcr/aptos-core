// Copyright (c) Aptos
// SPDX-License-Identifier: Apache-2.0

// This file is generated by rust-protobuf 3.1.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `src/protos/extractor.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_1_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:Transaction)
pub struct Transaction {
    // message fields
    // @@protoc_insertion_point(field:Transaction.timestamp)
    pub timestamp: u64,
    // @@protoc_insertion_point(field:Transaction.version)
    pub version: u64,
    // @@protoc_insertion_point(field:Transaction.info)
    pub info: ::protobuf::MessageField<TransactionInfo>,
    // @@protoc_insertion_point(field:Transaction.epoch)
    pub epoch: u64,
    // @@protoc_insertion_point(field:Transaction.block_height)
    pub block_height: u64,
    // @@protoc_insertion_point(field:Transaction.type)
    pub type_: ::protobuf::EnumOrUnknown<transaction::TransactionType>,
    // message oneof groups
    pub txn_data: ::std::option::Option<transaction::Txn_data>,
    // special fields
    // @@protoc_insertion_point(special_field:Transaction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Transaction {
    fn default() -> &'a Transaction {
        <Transaction as ::protobuf::Message>::default_instance()
    }
}

impl Transaction {
    pub fn new() -> Transaction {
        ::std::default::Default::default()
    }

    // .BlockMetadataTransaction block_metadata_txn = 7;

    pub fn block_metadata_txn(&self) -> &BlockMetadataTransaction {
        match self.txn_data {
            ::std::option::Option::Some(transaction::Txn_data::BlockMetadataTxn(ref v)) => v,
            _ => <BlockMetadataTransaction as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_block_metadata_txn(&mut self) {
        self.txn_data = ::std::option::Option::None;
    }

    pub fn has_block_metadata_txn(&self) -> bool {
        match self.txn_data {
            ::std::option::Option::Some(transaction::Txn_data::BlockMetadataTxn(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_block_metadata_txn(&mut self, v: BlockMetadataTransaction) {
        self.txn_data = ::std::option::Option::Some(transaction::Txn_data::BlockMetadataTxn(v))
    }

    // Mutable pointer to the field.
    pub fn mut_block_metadata_txn(&mut self) -> &mut BlockMetadataTransaction {
        if let ::std::option::Option::Some(transaction::Txn_data::BlockMetadataTxn(_)) = self.txn_data {
        } else {
            self.txn_data = ::std::option::Option::Some(transaction::Txn_data::BlockMetadataTxn(BlockMetadataTransaction::new()));
        }
        match self.txn_data {
            ::std::option::Option::Some(transaction::Txn_data::BlockMetadataTxn(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_block_metadata_txn(&mut self) -> BlockMetadataTransaction {
        if self.has_block_metadata_txn() {
            match self.txn_data.take() {
                ::std::option::Option::Some(transaction::Txn_data::BlockMetadataTxn(v)) => v,
                _ => panic!(),
            }
        } else {
            BlockMetadataTransaction::new()
        }
    }

    // .GenesisTransaction genesis_txn = 8;

    pub fn genesis_txn(&self) -> &GenesisTransaction {
        match self.txn_data {
            ::std::option::Option::Some(transaction::Txn_data::GenesisTxn(ref v)) => v,
            _ => <GenesisTransaction as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_genesis_txn(&mut self) {
        self.txn_data = ::std::option::Option::None;
    }

    pub fn has_genesis_txn(&self) -> bool {
        match self.txn_data {
            ::std::option::Option::Some(transaction::Txn_data::GenesisTxn(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_genesis_txn(&mut self, v: GenesisTransaction) {
        self.txn_data = ::std::option::Option::Some(transaction::Txn_data::GenesisTxn(v))
    }

    // Mutable pointer to the field.
    pub fn mut_genesis_txn(&mut self) -> &mut GenesisTransaction {
        if let ::std::option::Option::Some(transaction::Txn_data::GenesisTxn(_)) = self.txn_data {
        } else {
            self.txn_data = ::std::option::Option::Some(transaction::Txn_data::GenesisTxn(GenesisTransaction::new()));
        }
        match self.txn_data {
            ::std::option::Option::Some(transaction::Txn_data::GenesisTxn(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_genesis_txn(&mut self) -> GenesisTransaction {
        if self.has_genesis_txn() {
            match self.txn_data.take() {
                ::std::option::Option::Some(transaction::Txn_data::GenesisTxn(v)) => v,
                _ => panic!(),
            }
        } else {
            GenesisTransaction::new()
        }
    }

    // .StateCheckpointTransaction state_checkpoint_txn = 9;

    pub fn state_checkpoint_txn(&self) -> &StateCheckpointTransaction {
        match self.txn_data {
            ::std::option::Option::Some(transaction::Txn_data::StateCheckpointTxn(ref v)) => v,
            _ => <StateCheckpointTransaction as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_state_checkpoint_txn(&mut self) {
        self.txn_data = ::std::option::Option::None;
    }

    pub fn has_state_checkpoint_txn(&self) -> bool {
        match self.txn_data {
            ::std::option::Option::Some(transaction::Txn_data::StateCheckpointTxn(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_state_checkpoint_txn(&mut self, v: StateCheckpointTransaction) {
        self.txn_data = ::std::option::Option::Some(transaction::Txn_data::StateCheckpointTxn(v))
    }

    // Mutable pointer to the field.
    pub fn mut_state_checkpoint_txn(&mut self) -> &mut StateCheckpointTransaction {
        if let ::std::option::Option::Some(transaction::Txn_data::StateCheckpointTxn(_)) = self.txn_data {
        } else {
            self.txn_data = ::std::option::Option::Some(transaction::Txn_data::StateCheckpointTxn(StateCheckpointTransaction::new()));
        }
        match self.txn_data {
            ::std::option::Option::Some(transaction::Txn_data::StateCheckpointTxn(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_state_checkpoint_txn(&mut self) -> StateCheckpointTransaction {
        if self.has_state_checkpoint_txn() {
            match self.txn_data.take() {
                ::std::option::Option::Some(transaction::Txn_data::StateCheckpointTxn(v)) => v,
                _ => panic!(),
            }
        } else {
            StateCheckpointTransaction::new()
        }
    }

    // .UserTransaction user_txn = 10;

    pub fn user_txn(&self) -> &UserTransaction {
        match self.txn_data {
            ::std::option::Option::Some(transaction::Txn_data::UserTxn(ref v)) => v,
            _ => <UserTransaction as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_user_txn(&mut self) {
        self.txn_data = ::std::option::Option::None;
    }

    pub fn has_user_txn(&self) -> bool {
        match self.txn_data {
            ::std::option::Option::Some(transaction::Txn_data::UserTxn(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_user_txn(&mut self, v: UserTransaction) {
        self.txn_data = ::std::option::Option::Some(transaction::Txn_data::UserTxn(v))
    }

    // Mutable pointer to the field.
    pub fn mut_user_txn(&mut self) -> &mut UserTransaction {
        if let ::std::option::Option::Some(transaction::Txn_data::UserTxn(_)) = self.txn_data {
        } else {
            self.txn_data = ::std::option::Option::Some(transaction::Txn_data::UserTxn(UserTransaction::new()));
        }
        match self.txn_data {
            ::std::option::Option::Some(transaction::Txn_data::UserTxn(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_user_txn(&mut self) -> UserTransaction {
        if self.has_user_txn() {
            match self.txn_data.take() {
                ::std::option::Option::Some(transaction::Txn_data::UserTxn(v)) => v,
                _ => panic!(),
            }
        } else {
            UserTransaction::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "timestamp",
            |m: &Transaction| { &m.timestamp },
            |m: &mut Transaction| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version",
            |m: &Transaction| { &m.version },
            |m: &mut Transaction| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TransactionInfo>(
            "info",
            |m: &Transaction| { &m.info },
            |m: &mut Transaction| { &mut m.info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "epoch",
            |m: &Transaction| { &m.epoch },
            |m: &mut Transaction| { &mut m.epoch },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "block_height",
            |m: &Transaction| { &m.block_height },
            |m: &mut Transaction| { &mut m.block_height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &Transaction| { &m.type_ },
            |m: &mut Transaction| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, BlockMetadataTransaction>(
            "block_metadata_txn",
            Transaction::has_block_metadata_txn,
            Transaction::block_metadata_txn,
            Transaction::mut_block_metadata_txn,
            Transaction::set_block_metadata_txn,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, GenesisTransaction>(
            "genesis_txn",
            Transaction::has_genesis_txn,
            Transaction::genesis_txn,
            Transaction::mut_genesis_txn,
            Transaction::set_genesis_txn,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, StateCheckpointTransaction>(
            "state_checkpoint_txn",
            Transaction::has_state_checkpoint_txn,
            Transaction::state_checkpoint_txn,
            Transaction::mut_state_checkpoint_txn,
            Transaction::set_state_checkpoint_txn,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, UserTransaction>(
            "user_txn",
            Transaction::has_user_txn,
            Transaction::user_txn,
            Transaction::mut_user_txn,
            Transaction::set_user_txn,
        ));
        oneofs.push(transaction::Txn_data::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Transaction>(
            "Transaction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Transaction {
    const NAME: &'static str = "Transaction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.timestamp = is.read_uint64()?;
                },
                16 => {
                    self.version = is.read_uint64()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.info)?;
                },
                32 => {
                    self.epoch = is.read_uint64()?;
                },
                40 => {
                    self.block_height = is.read_uint64()?;
                },
                48 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                58 => {
                    self.txn_data = ::std::option::Option::Some(transaction::Txn_data::BlockMetadataTxn(is.read_message()?));
                },
                66 => {
                    self.txn_data = ::std::option::Option::Some(transaction::Txn_data::GenesisTxn(is.read_message()?));
                },
                74 => {
                    self.txn_data = ::std::option::Option::Some(transaction::Txn_data::StateCheckpointTxn(is.read_message()?));
                },
                82 => {
                    self.txn_data = ::std::option::Option::Some(transaction::Txn_data::UserTxn(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.timestamp);
        }
        if self.version != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.version);
        }
        if let Some(v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.epoch != 0 {
            my_size += ::protobuf::rt::uint64_size(4, self.epoch);
        }
        if self.block_height != 0 {
            my_size += ::protobuf::rt::uint64_size(5, self.block_height);
        }
        if self.type_ != ::protobuf::EnumOrUnknown::new(transaction::TransactionType::GENESIS) {
            my_size += ::protobuf::rt::int32_size(6, self.type_.value());
        }
        if let ::std::option::Option::Some(ref v) = self.txn_data {
            match v {
                &transaction::Txn_data::BlockMetadataTxn(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &transaction::Txn_data::GenesisTxn(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &transaction::Txn_data::StateCheckpointTxn(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &transaction::Txn_data::UserTxn(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.timestamp != 0 {
            os.write_uint64(1, self.timestamp)?;
        }
        if self.version != 0 {
            os.write_uint64(2, self.version)?;
        }
        if let Some(v) = self.info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if self.epoch != 0 {
            os.write_uint64(4, self.epoch)?;
        }
        if self.block_height != 0 {
            os.write_uint64(5, self.block_height)?;
        }
        if self.type_ != ::protobuf::EnumOrUnknown::new(transaction::TransactionType::GENESIS) {
            os.write_enum(6, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        if let ::std::option::Option::Some(ref v) = self.txn_data {
            match v {
                &transaction::Txn_data::BlockMetadataTxn(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                },
                &transaction::Txn_data::GenesisTxn(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
                },
                &transaction::Txn_data::StateCheckpointTxn(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
                },
                &transaction::Txn_data::UserTxn(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Transaction {
        Transaction::new()
    }

    fn clear(&mut self) {
        self.timestamp = 0;
        self.version = 0;
        self.info.clear();
        self.epoch = 0;
        self.block_height = 0;
        self.type_ = ::protobuf::EnumOrUnknown::new(transaction::TransactionType::GENESIS);
        self.txn_data = ::std::option::Option::None;
        self.txn_data = ::std::option::Option::None;
        self.txn_data = ::std::option::Option::None;
        self.txn_data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Transaction {
        static instance: Transaction = Transaction {
            timestamp: 0,
            version: 0,
            info: ::protobuf::MessageField::none(),
            epoch: 0,
            block_height: 0,
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            txn_data: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Transaction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Transaction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Transaction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Transaction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Transaction`
pub mod transaction {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:Transaction.txn_data)
    pub enum Txn_data {
        // @@protoc_insertion_point(oneof_field:Transaction.block_metadata_txn)
        BlockMetadataTxn(super::BlockMetadataTransaction),
        // @@protoc_insertion_point(oneof_field:Transaction.genesis_txn)
        GenesisTxn(super::GenesisTransaction),
        // @@protoc_insertion_point(oneof_field:Transaction.state_checkpoint_txn)
        StateCheckpointTxn(super::StateCheckpointTransaction),
        // @@protoc_insertion_point(oneof_field:Transaction.user_txn)
        UserTxn(super::UserTransaction),
    }

    impl ::protobuf::Oneof for Txn_data {
    }

    impl ::protobuf::OneofFull for Txn_data {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::Transaction as ::protobuf::MessageFull>::descriptor().oneof_by_name("txn_data").unwrap()).clone()
        }
    }

    impl Txn_data {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Txn_data>("txn_data")
        }
    }
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:Transaction.TransactionType)
    pub enum TransactionType {
        // @@protoc_insertion_point(enum_value:Transaction.TransactionType.GENESIS)
        GENESIS = 0,
        // @@protoc_insertion_point(enum_value:Transaction.TransactionType.BLOCK_METADATA)
        BLOCK_METADATA = 1,
        // @@protoc_insertion_point(enum_value:Transaction.TransactionType.STATE_CHECKPOINT)
        STATE_CHECKPOINT = 2,
        // @@protoc_insertion_point(enum_value:Transaction.TransactionType.USER)
        USER = 3,
    }

    impl ::protobuf::Enum for TransactionType {
        const NAME: &'static str = "TransactionType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<TransactionType> {
            match value {
                0 => ::std::option::Option::Some(TransactionType::GENESIS),
                1 => ::std::option::Option::Some(TransactionType::BLOCK_METADATA),
                2 => ::std::option::Option::Some(TransactionType::STATE_CHECKPOINT),
                3 => ::std::option::Option::Some(TransactionType::USER),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [TransactionType] = &[
            TransactionType::GENESIS,
            TransactionType::BLOCK_METADATA,
            TransactionType::STATE_CHECKPOINT,
            TransactionType::USER,
        ];
    }

    impl ::protobuf::EnumFull for TransactionType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("Transaction.TransactionType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for TransactionType {
        fn default() -> Self {
            TransactionType::GENESIS
        }
    }

    impl TransactionType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<TransactionType>("Transaction.TransactionType")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:BlockMetadataTransaction)
pub struct BlockMetadataTransaction {
    // message fields
    // @@protoc_insertion_point(field:BlockMetadataTransaction.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:BlockMetadataTransaction.round)
    pub round: u64,
    // @@protoc_insertion_point(field:BlockMetadataTransaction.events)
    pub events: ::std::vec::Vec<Event>,
    // @@protoc_insertion_point(field:BlockMetadataTransaction.previous_block_votes)
    pub previous_block_votes: ::std::vec::Vec<bool>,
    // @@protoc_insertion_point(field:BlockMetadataTransaction.proposer)
    pub proposer: ::std::string::String,
    // @@protoc_insertion_point(field:BlockMetadataTransaction.failed_proposer_indices)
    pub failed_proposer_indices: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:BlockMetadataTransaction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BlockMetadataTransaction {
    fn default() -> &'a BlockMetadataTransaction {
        <BlockMetadataTransaction as ::protobuf::Message>::default_instance()
    }
}

impl BlockMetadataTransaction {
    pub fn new() -> BlockMetadataTransaction {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &BlockMetadataTransaction| { &m.id },
            |m: &mut BlockMetadataTransaction| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "round",
            |m: &BlockMetadataTransaction| { &m.round },
            |m: &mut BlockMetadataTransaction| { &mut m.round },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "events",
            |m: &BlockMetadataTransaction| { &m.events },
            |m: &mut BlockMetadataTransaction| { &mut m.events },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "previous_block_votes",
            |m: &BlockMetadataTransaction| { &m.previous_block_votes },
            |m: &mut BlockMetadataTransaction| { &mut m.previous_block_votes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "proposer",
            |m: &BlockMetadataTransaction| { &m.proposer },
            |m: &mut BlockMetadataTransaction| { &mut m.proposer },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "failed_proposer_indices",
            |m: &BlockMetadataTransaction| { &m.failed_proposer_indices },
            |m: &mut BlockMetadataTransaction| { &mut m.failed_proposer_indices },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BlockMetadataTransaction>(
            "BlockMetadataTransaction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BlockMetadataTransaction {
    const NAME: &'static str = "BlockMetadataTransaction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                16 => {
                    self.round = is.read_uint64()?;
                },
                26 => {
                    self.events.push(is.read_message()?);
                },
                34 => {
                    is.read_repeated_packed_bool_into(&mut self.previous_block_votes)?;
                },
                32 => {
                    self.previous_block_votes.push(is.read_bool()?);
                },
                42 => {
                    self.proposer = is.read_string()?;
                },
                50 => {
                    is.read_repeated_packed_uint32_into(&mut self.failed_proposer_indices)?;
                },
                48 => {
                    self.failed_proposer_indices.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if self.round != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.round);
        }
        for value in &self.events {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += 2 * self.previous_block_votes.len() as u64;
        if !self.proposer.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.proposer);
        }
        for value in &self.failed_proposer_indices {
            my_size += ::protobuf::rt::uint32_size(6, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if self.round != 0 {
            os.write_uint64(2, self.round)?;
        }
        for v in &self.events {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.previous_block_votes {
            os.write_bool(4, *v)?;
        };
        if !self.proposer.is_empty() {
            os.write_string(5, &self.proposer)?;
        }
        for v in &self.failed_proposer_indices {
            os.write_uint32(6, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BlockMetadataTransaction {
        BlockMetadataTransaction::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.round = 0;
        self.events.clear();
        self.previous_block_votes.clear();
        self.proposer.clear();
        self.failed_proposer_indices.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BlockMetadataTransaction {
        static instance: BlockMetadataTransaction = BlockMetadataTransaction {
            id: ::std::string::String::new(),
            round: 0,
            events: ::std::vec::Vec::new(),
            previous_block_votes: ::std::vec::Vec::new(),
            proposer: ::std::string::String::new(),
            failed_proposer_indices: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BlockMetadataTransaction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BlockMetadataTransaction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BlockMetadataTransaction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockMetadataTransaction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:GenesisTransaction)
pub struct GenesisTransaction {
    // message fields
    // @@protoc_insertion_point(field:GenesisTransaction.payload)
    pub payload: ::protobuf::MessageField<WriteSet>,
    // @@protoc_insertion_point(field:GenesisTransaction.events)
    pub events: ::std::vec::Vec<Event>,
    // special fields
    // @@protoc_insertion_point(special_field:GenesisTransaction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GenesisTransaction {
    fn default() -> &'a GenesisTransaction {
        <GenesisTransaction as ::protobuf::Message>::default_instance()
    }
}

impl GenesisTransaction {
    pub fn new() -> GenesisTransaction {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, WriteSet>(
            "payload",
            |m: &GenesisTransaction| { &m.payload },
            |m: &mut GenesisTransaction| { &mut m.payload },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "events",
            |m: &GenesisTransaction| { &m.events },
            |m: &mut GenesisTransaction| { &mut m.events },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GenesisTransaction>(
            "GenesisTransaction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GenesisTransaction {
    const NAME: &'static str = "GenesisTransaction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.payload)?;
                },
                18 => {
                    self.events.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payload.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.events {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payload.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.events {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GenesisTransaction {
        GenesisTransaction::new()
    }

    fn clear(&mut self) {
        self.payload.clear();
        self.events.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GenesisTransaction {
        static instance: GenesisTransaction = GenesisTransaction {
            payload: ::protobuf::MessageField::none(),
            events: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GenesisTransaction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GenesisTransaction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GenesisTransaction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GenesisTransaction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:StateCheckpointTransaction)
pub struct StateCheckpointTransaction {
    // special fields
    // @@protoc_insertion_point(special_field:StateCheckpointTransaction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StateCheckpointTransaction {
    fn default() -> &'a StateCheckpointTransaction {
        <StateCheckpointTransaction as ::protobuf::Message>::default_instance()
    }
}

impl StateCheckpointTransaction {
    pub fn new() -> StateCheckpointTransaction {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StateCheckpointTransaction>(
            "StateCheckpointTransaction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StateCheckpointTransaction {
    const NAME: &'static str = "StateCheckpointTransaction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StateCheckpointTransaction {
        StateCheckpointTransaction::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StateCheckpointTransaction {
        static instance: StateCheckpointTransaction = StateCheckpointTransaction {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StateCheckpointTransaction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StateCheckpointTransaction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StateCheckpointTransaction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StateCheckpointTransaction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:UserTransaction)
pub struct UserTransaction {
    // message fields
    // @@protoc_insertion_point(field:UserTransaction.request)
    pub request: ::protobuf::MessageField<UserTransactionRequest>,
    // @@protoc_insertion_point(field:UserTransaction.events)
    pub events: ::std::vec::Vec<Event>,
    // special fields
    // @@protoc_insertion_point(special_field:UserTransaction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UserTransaction {
    fn default() -> &'a UserTransaction {
        <UserTransaction as ::protobuf::Message>::default_instance()
    }
}

impl UserTransaction {
    pub fn new() -> UserTransaction {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, UserTransactionRequest>(
            "request",
            |m: &UserTransaction| { &m.request },
            |m: &mut UserTransaction| { &mut m.request },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "events",
            |m: &UserTransaction| { &m.events },
            |m: &mut UserTransaction| { &mut m.events },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserTransaction>(
            "UserTransaction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UserTransaction {
    const NAME: &'static str = "UserTransaction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.request)?;
                },
                18 => {
                    self.events.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.request.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.events {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.request.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.events {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UserTransaction {
        UserTransaction::new()
    }

    fn clear(&mut self) {
        self.request.clear();
        self.events.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UserTransaction {
        static instance: UserTransaction = UserTransaction {
            request: ::protobuf::MessageField::none(),
            events: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UserTransaction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UserTransaction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UserTransaction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserTransaction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:Event)
pub struct Event {
    // message fields
    // @@protoc_insertion_point(field:Event.key)
    pub key: ::protobuf::MessageField<EventKey>,
    // @@protoc_insertion_point(field:Event.sequence_number)
    pub sequence_number: u64,
    // @@protoc_insertion_point(field:Event.type)
    pub type_: ::std::string::String,
    // @@protoc_insertion_point(field:Event.data)
    pub data: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:Event.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Event {
    fn default() -> &'a Event {
        <Event as ::protobuf::Message>::default_instance()
    }
}

impl Event {
    pub fn new() -> Event {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, EventKey>(
            "key",
            |m: &Event| { &m.key },
            |m: &mut Event| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sequence_number",
            |m: &Event| { &m.sequence_number },
            |m: &mut Event| { &mut m.sequence_number },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &Event| { &m.type_ },
            |m: &mut Event| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data",
            |m: &Event| { &m.data },
            |m: &mut Event| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Event>(
            "Event",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Event {
    const NAME: &'static str = "Event";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.key)?;
                },
                16 => {
                    self.sequence_number = is.read_uint64()?;
                },
                26 => {
                    self.type_ = is.read_string()?;
                },
                34 => {
                    self.data = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.key.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.sequence_number != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.sequence_number);
        }
        if !self.type_.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.type_);
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.key.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.sequence_number != 0 {
            os.write_uint64(2, self.sequence_number)?;
        }
        if !self.type_.is_empty() {
            os.write_string(3, &self.type_)?;
        }
        if !self.data.is_empty() {
            os.write_string(4, &self.data)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Event {
        Event::new()
    }

    fn clear(&mut self) {
        self.key.clear();
        self.sequence_number = 0;
        self.type_.clear();
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Event {
        static instance: Event = Event {
            key: ::protobuf::MessageField::none(),
            sequence_number: 0,
            type_: ::std::string::String::new(),
            data: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Event {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Event").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Event {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Event {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:TransactionInfo)
pub struct TransactionInfo {
    // message fields
    // @@protoc_insertion_point(field:TransactionInfo.hash)
    pub hash: ::std::string::String,
    // @@protoc_insertion_point(field:TransactionInfo.state_root_hash)
    pub state_root_hash: ::std::string::String,
    // @@protoc_insertion_point(field:TransactionInfo.event_root_hash)
    pub event_root_hash: ::std::string::String,
    // @@protoc_insertion_point(field:TransactionInfo.gas_used)
    pub gas_used: u64,
    // @@protoc_insertion_point(field:TransactionInfo.success)
    pub success: bool,
    // @@protoc_insertion_point(field:TransactionInfo.vm_status)
    pub vm_status: ::std::string::String,
    // @@protoc_insertion_point(field:TransactionInfo.accumulator_root_hash)
    pub accumulator_root_hash: ::std::string::String,
    // @@protoc_insertion_point(field:TransactionInfo.changes)
    pub changes: ::std::vec::Vec<WriteSetChange>,
    // special fields
    // @@protoc_insertion_point(special_field:TransactionInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TransactionInfo {
    fn default() -> &'a TransactionInfo {
        <TransactionInfo as ::protobuf::Message>::default_instance()
    }
}

impl TransactionInfo {
    pub fn new() -> TransactionInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hash",
            |m: &TransactionInfo| { &m.hash },
            |m: &mut TransactionInfo| { &mut m.hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "state_root_hash",
            |m: &TransactionInfo| { &m.state_root_hash },
            |m: &mut TransactionInfo| { &mut m.state_root_hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "event_root_hash",
            |m: &TransactionInfo| { &m.event_root_hash },
            |m: &mut TransactionInfo| { &mut m.event_root_hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "gas_used",
            |m: &TransactionInfo| { &m.gas_used },
            |m: &mut TransactionInfo| { &mut m.gas_used },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "success",
            |m: &TransactionInfo| { &m.success },
            |m: &mut TransactionInfo| { &mut m.success },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "vm_status",
            |m: &TransactionInfo| { &m.vm_status },
            |m: &mut TransactionInfo| { &mut m.vm_status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "accumulator_root_hash",
            |m: &TransactionInfo| { &m.accumulator_root_hash },
            |m: &mut TransactionInfo| { &mut m.accumulator_root_hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "changes",
            |m: &TransactionInfo| { &m.changes },
            |m: &mut TransactionInfo| { &mut m.changes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TransactionInfo>(
            "TransactionInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TransactionInfo {
    const NAME: &'static str = "TransactionInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.hash = is.read_string()?;
                },
                18 => {
                    self.state_root_hash = is.read_string()?;
                },
                26 => {
                    self.event_root_hash = is.read_string()?;
                },
                32 => {
                    self.gas_used = is.read_uint64()?;
                },
                40 => {
                    self.success = is.read_bool()?;
                },
                50 => {
                    self.vm_status = is.read_string()?;
                },
                58 => {
                    self.accumulator_root_hash = is.read_string()?;
                },
                66 => {
                    self.changes.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.hash);
        }
        if !self.state_root_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.state_root_hash);
        }
        if !self.event_root_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.event_root_hash);
        }
        if self.gas_used != 0 {
            my_size += ::protobuf::rt::uint64_size(4, self.gas_used);
        }
        if self.success != false {
            my_size += 1 + 1;
        }
        if !self.vm_status.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.vm_status);
        }
        if !self.accumulator_root_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.accumulator_root_hash);
        }
        for value in &self.changes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.hash.is_empty() {
            os.write_string(1, &self.hash)?;
        }
        if !self.state_root_hash.is_empty() {
            os.write_string(2, &self.state_root_hash)?;
        }
        if !self.event_root_hash.is_empty() {
            os.write_string(3, &self.event_root_hash)?;
        }
        if self.gas_used != 0 {
            os.write_uint64(4, self.gas_used)?;
        }
        if self.success != false {
            os.write_bool(5, self.success)?;
        }
        if !self.vm_status.is_empty() {
            os.write_string(6, &self.vm_status)?;
        }
        if !self.accumulator_root_hash.is_empty() {
            os.write_string(7, &self.accumulator_root_hash)?;
        }
        for v in &self.changes {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TransactionInfo {
        TransactionInfo::new()
    }

    fn clear(&mut self) {
        self.hash.clear();
        self.state_root_hash.clear();
        self.event_root_hash.clear();
        self.gas_used = 0;
        self.success = false;
        self.vm_status.clear();
        self.accumulator_root_hash.clear();
        self.changes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TransactionInfo {
        static instance: TransactionInfo = TransactionInfo {
            hash: ::std::string::String::new(),
            state_root_hash: ::std::string::String::new(),
            event_root_hash: ::std::string::String::new(),
            gas_used: 0,
            success: false,
            vm_status: ::std::string::String::new(),
            accumulator_root_hash: ::std::string::String::new(),
            changes: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TransactionInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TransactionInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TransactionInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:EventKey)
pub struct EventKey {
    // message fields
    // @@protoc_insertion_point(field:EventKey.creation_number)
    pub creation_number: u64,
    // @@protoc_insertion_point(field:EventKey.account_address)
    pub account_address: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:EventKey.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EventKey {
    fn default() -> &'a EventKey {
        <EventKey as ::protobuf::Message>::default_instance()
    }
}

impl EventKey {
    pub fn new() -> EventKey {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "creation_number",
            |m: &EventKey| { &m.creation_number },
            |m: &mut EventKey| { &mut m.creation_number },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "account_address",
            |m: &EventKey| { &m.account_address },
            |m: &mut EventKey| { &mut m.account_address },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EventKey>(
            "EventKey",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EventKey {
    const NAME: &'static str = "EventKey";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.creation_number = is.read_uint64()?;
                },
                18 => {
                    self.account_address = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.creation_number != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.creation_number);
        }
        if !self.account_address.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.account_address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.creation_number != 0 {
            os.write_uint64(1, self.creation_number)?;
        }
        if !self.account_address.is_empty() {
            os.write_string(2, &self.account_address)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EventKey {
        EventKey::new()
    }

    fn clear(&mut self) {
        self.creation_number = 0;
        self.account_address.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EventKey {
        static instance: EventKey = EventKey {
            creation_number: 0,
            account_address: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EventKey {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EventKey").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EventKey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EventKey {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:UserTransactionRequest)
pub struct UserTransactionRequest {
    // message fields
    // @@protoc_insertion_point(field:UserTransactionRequest.sender)
    pub sender: ::std::string::String,
    // @@protoc_insertion_point(field:UserTransactionRequest.sequence_number)
    pub sequence_number: u64,
    // @@protoc_insertion_point(field:UserTransactionRequest.max_gas_amount)
    pub max_gas_amount: u64,
    // @@protoc_insertion_point(field:UserTransactionRequest.gas_unit_price)
    pub gas_unit_price: u64,
    // @@protoc_insertion_point(field:UserTransactionRequest.expiration_timestamp_secs)
    pub expiration_timestamp_secs: u64,
    // @@protoc_insertion_point(field:UserTransactionRequest.payload)
    pub payload: ::protobuf::MessageField<TransactionPayload>,
    // @@protoc_insertion_point(field:UserTransactionRequest.signature)
    pub signature: ::protobuf::MessageField<Signature>,
    // special fields
    // @@protoc_insertion_point(special_field:UserTransactionRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UserTransactionRequest {
    fn default() -> &'a UserTransactionRequest {
        <UserTransactionRequest as ::protobuf::Message>::default_instance()
    }
}

impl UserTransactionRequest {
    pub fn new() -> UserTransactionRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sender",
            |m: &UserTransactionRequest| { &m.sender },
            |m: &mut UserTransactionRequest| { &mut m.sender },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sequence_number",
            |m: &UserTransactionRequest| { &m.sequence_number },
            |m: &mut UserTransactionRequest| { &mut m.sequence_number },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "max_gas_amount",
            |m: &UserTransactionRequest| { &m.max_gas_amount },
            |m: &mut UserTransactionRequest| { &mut m.max_gas_amount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "gas_unit_price",
            |m: &UserTransactionRequest| { &m.gas_unit_price },
            |m: &mut UserTransactionRequest| { &mut m.gas_unit_price },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "expiration_timestamp_secs",
            |m: &UserTransactionRequest| { &m.expiration_timestamp_secs },
            |m: &mut UserTransactionRequest| { &mut m.expiration_timestamp_secs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TransactionPayload>(
            "payload",
            |m: &UserTransactionRequest| { &m.payload },
            |m: &mut UserTransactionRequest| { &mut m.payload },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Signature>(
            "signature",
            |m: &UserTransactionRequest| { &m.signature },
            |m: &mut UserTransactionRequest| { &mut m.signature },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserTransactionRequest>(
            "UserTransactionRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UserTransactionRequest {
    const NAME: &'static str = "UserTransactionRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.sender = is.read_string()?;
                },
                16 => {
                    self.sequence_number = is.read_uint64()?;
                },
                24 => {
                    self.max_gas_amount = is.read_uint64()?;
                },
                32 => {
                    self.gas_unit_price = is.read_uint64()?;
                },
                40 => {
                    self.expiration_timestamp_secs = is.read_uint64()?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.payload)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.signature)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.sender.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.sender);
        }
        if self.sequence_number != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.sequence_number);
        }
        if self.max_gas_amount != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.max_gas_amount);
        }
        if self.gas_unit_price != 0 {
            my_size += ::protobuf::rt::uint64_size(4, self.gas_unit_price);
        }
        if self.expiration_timestamp_secs != 0 {
            my_size += ::protobuf::rt::uint64_size(5, self.expiration_timestamp_secs);
        }
        if let Some(v) = self.payload.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.signature.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.sender.is_empty() {
            os.write_string(1, &self.sender)?;
        }
        if self.sequence_number != 0 {
            os.write_uint64(2, self.sequence_number)?;
        }
        if self.max_gas_amount != 0 {
            os.write_uint64(3, self.max_gas_amount)?;
        }
        if self.gas_unit_price != 0 {
            os.write_uint64(4, self.gas_unit_price)?;
        }
        if self.expiration_timestamp_secs != 0 {
            os.write_uint64(5, self.expiration_timestamp_secs)?;
        }
        if let Some(v) = self.payload.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.signature.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UserTransactionRequest {
        UserTransactionRequest::new()
    }

    fn clear(&mut self) {
        self.sender.clear();
        self.sequence_number = 0;
        self.max_gas_amount = 0;
        self.gas_unit_price = 0;
        self.expiration_timestamp_secs = 0;
        self.payload.clear();
        self.signature.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UserTransactionRequest {
        static instance: UserTransactionRequest = UserTransactionRequest {
            sender: ::std::string::String::new(),
            sequence_number: 0,
            max_gas_amount: 0,
            gas_unit_price: 0,
            expiration_timestamp_secs: 0,
            payload: ::protobuf::MessageField::none(),
            signature: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UserTransactionRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UserTransactionRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UserTransactionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserTransactionRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:WriteSet)
pub struct WriteSet {
    // message fields
    // @@protoc_insertion_point(field:WriteSet.write_set_type)
    pub write_set_type: ::protobuf::EnumOrUnknown<write_set::WriteSetType>,
    // message oneof groups
    pub write_set: ::std::option::Option<write_set::Write_set>,
    // special fields
    // @@protoc_insertion_point(special_field:WriteSet.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WriteSet {
    fn default() -> &'a WriteSet {
        <WriteSet as ::protobuf::Message>::default_instance()
    }
}

impl WriteSet {
    pub fn new() -> WriteSet {
        ::std::default::Default::default()
    }

    // .ScriptWriteSet script_write_set = 2;

    pub fn script_write_set(&self) -> &ScriptWriteSet {
        match self.write_set {
            ::std::option::Option::Some(write_set::Write_set::ScriptWriteSet(ref v)) => v,
            _ => <ScriptWriteSet as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_script_write_set(&mut self) {
        self.write_set = ::std::option::Option::None;
    }

    pub fn has_script_write_set(&self) -> bool {
        match self.write_set {
            ::std::option::Option::Some(write_set::Write_set::ScriptWriteSet(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_script_write_set(&mut self, v: ScriptWriteSet) {
        self.write_set = ::std::option::Option::Some(write_set::Write_set::ScriptWriteSet(v))
    }

    // Mutable pointer to the field.
    pub fn mut_script_write_set(&mut self) -> &mut ScriptWriteSet {
        if let ::std::option::Option::Some(write_set::Write_set::ScriptWriteSet(_)) = self.write_set {
        } else {
            self.write_set = ::std::option::Option::Some(write_set::Write_set::ScriptWriteSet(ScriptWriteSet::new()));
        }
        match self.write_set {
            ::std::option::Option::Some(write_set::Write_set::ScriptWriteSet(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_script_write_set(&mut self) -> ScriptWriteSet {
        if self.has_script_write_set() {
            match self.write_set.take() {
                ::std::option::Option::Some(write_set::Write_set::ScriptWriteSet(v)) => v,
                _ => panic!(),
            }
        } else {
            ScriptWriteSet::new()
        }
    }

    // .DirectWriteSet direct_write_set = 3;

    pub fn direct_write_set(&self) -> &DirectWriteSet {
        match self.write_set {
            ::std::option::Option::Some(write_set::Write_set::DirectWriteSet(ref v)) => v,
            _ => <DirectWriteSet as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_direct_write_set(&mut self) {
        self.write_set = ::std::option::Option::None;
    }

    pub fn has_direct_write_set(&self) -> bool {
        match self.write_set {
            ::std::option::Option::Some(write_set::Write_set::DirectWriteSet(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_direct_write_set(&mut self, v: DirectWriteSet) {
        self.write_set = ::std::option::Option::Some(write_set::Write_set::DirectWriteSet(v))
    }

    // Mutable pointer to the field.
    pub fn mut_direct_write_set(&mut self) -> &mut DirectWriteSet {
        if let ::std::option::Option::Some(write_set::Write_set::DirectWriteSet(_)) = self.write_set {
        } else {
            self.write_set = ::std::option::Option::Some(write_set::Write_set::DirectWriteSet(DirectWriteSet::new()));
        }
        match self.write_set {
            ::std::option::Option::Some(write_set::Write_set::DirectWriteSet(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_direct_write_set(&mut self) -> DirectWriteSet {
        if self.has_direct_write_set() {
            match self.write_set.take() {
                ::std::option::Option::Some(write_set::Write_set::DirectWriteSet(v)) => v,
                _ => panic!(),
            }
        } else {
            DirectWriteSet::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "write_set_type",
            |m: &WriteSet| { &m.write_set_type },
            |m: &mut WriteSet| { &mut m.write_set_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ScriptWriteSet>(
            "script_write_set",
            WriteSet::has_script_write_set,
            WriteSet::script_write_set,
            WriteSet::mut_script_write_set,
            WriteSet::set_script_write_set,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, DirectWriteSet>(
            "direct_write_set",
            WriteSet::has_direct_write_set,
            WriteSet::direct_write_set,
            WriteSet::mut_direct_write_set,
            WriteSet::set_direct_write_set,
        ));
        oneofs.push(write_set::Write_set::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WriteSet>(
            "WriteSet",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WriteSet {
    const NAME: &'static str = "WriteSet";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.write_set_type = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.write_set = ::std::option::Option::Some(write_set::Write_set::ScriptWriteSet(is.read_message()?));
                },
                26 => {
                    self.write_set = ::std::option::Option::Some(write_set::Write_set::DirectWriteSet(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.write_set_type != ::protobuf::EnumOrUnknown::new(write_set::WriteSetType::SCRIPT_WRITE_SET) {
            my_size += ::protobuf::rt::int32_size(1, self.write_set_type.value());
        }
        if let ::std::option::Option::Some(ref v) = self.write_set {
            match v {
                &write_set::Write_set::ScriptWriteSet(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &write_set::Write_set::DirectWriteSet(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.write_set_type != ::protobuf::EnumOrUnknown::new(write_set::WriteSetType::SCRIPT_WRITE_SET) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.write_set_type))?;
        }
        if let ::std::option::Option::Some(ref v) = self.write_set {
            match v {
                &write_set::Write_set::ScriptWriteSet(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &write_set::Write_set::DirectWriteSet(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WriteSet {
        WriteSet::new()
    }

    fn clear(&mut self) {
        self.write_set_type = ::protobuf::EnumOrUnknown::new(write_set::WriteSetType::SCRIPT_WRITE_SET);
        self.write_set = ::std::option::Option::None;
        self.write_set = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WriteSet {
        static instance: WriteSet = WriteSet {
            write_set_type: ::protobuf::EnumOrUnknown::from_i32(0),
            write_set: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WriteSet {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WriteSet").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WriteSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WriteSet {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `WriteSet`
pub mod write_set {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:WriteSet.write_set)
    pub enum Write_set {
        // @@protoc_insertion_point(oneof_field:WriteSet.script_write_set)
        ScriptWriteSet(super::ScriptWriteSet),
        // @@protoc_insertion_point(oneof_field:WriteSet.direct_write_set)
        DirectWriteSet(super::DirectWriteSet),
    }

    impl ::protobuf::Oneof for Write_set {
    }

    impl ::protobuf::OneofFull for Write_set {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::WriteSet as ::protobuf::MessageFull>::descriptor().oneof_by_name("write_set").unwrap()).clone()
        }
    }

    impl Write_set {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Write_set>("write_set")
        }
    }
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:WriteSet.WriteSetType)
    pub enum WriteSetType {
        // @@protoc_insertion_point(enum_value:WriteSet.WriteSetType.SCRIPT_WRITE_SET)
        SCRIPT_WRITE_SET = 0,
        // @@protoc_insertion_point(enum_value:WriteSet.WriteSetType.DIRECT_WRITE_SET)
        DIRECT_WRITE_SET = 1,
    }

    impl ::protobuf::Enum for WriteSetType {
        const NAME: &'static str = "WriteSetType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<WriteSetType> {
            match value {
                0 => ::std::option::Option::Some(WriteSetType::SCRIPT_WRITE_SET),
                1 => ::std::option::Option::Some(WriteSetType::DIRECT_WRITE_SET),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [WriteSetType] = &[
            WriteSetType::SCRIPT_WRITE_SET,
            WriteSetType::DIRECT_WRITE_SET,
        ];
    }

    impl ::protobuf::EnumFull for WriteSetType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("WriteSet.WriteSetType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for WriteSetType {
        fn default() -> Self {
            WriteSetType::SCRIPT_WRITE_SET
        }
    }

    impl WriteSetType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<WriteSetType>("WriteSet.WriteSetType")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ScriptWriteSet)
pub struct ScriptWriteSet {
    // message fields
    // @@protoc_insertion_point(field:ScriptWriteSet.execute_as)
    pub execute_as: ::std::string::String,
    // @@protoc_insertion_point(field:ScriptWriteSet.script)
    pub script: ::protobuf::MessageField<ScriptPayload>,
    // special fields
    // @@protoc_insertion_point(special_field:ScriptWriteSet.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ScriptWriteSet {
    fn default() -> &'a ScriptWriteSet {
        <ScriptWriteSet as ::protobuf::Message>::default_instance()
    }
}

impl ScriptWriteSet {
    pub fn new() -> ScriptWriteSet {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "execute_as",
            |m: &ScriptWriteSet| { &m.execute_as },
            |m: &mut ScriptWriteSet| { &mut m.execute_as },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ScriptPayload>(
            "script",
            |m: &ScriptWriteSet| { &m.script },
            |m: &mut ScriptWriteSet| { &mut m.script },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ScriptWriteSet>(
            "ScriptWriteSet",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ScriptWriteSet {
    const NAME: &'static str = "ScriptWriteSet";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.execute_as = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.script)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.execute_as.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.execute_as);
        }
        if let Some(v) = self.script.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.execute_as.is_empty() {
            os.write_string(1, &self.execute_as)?;
        }
        if let Some(v) = self.script.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ScriptWriteSet {
        ScriptWriteSet::new()
    }

    fn clear(&mut self) {
        self.execute_as.clear();
        self.script.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ScriptWriteSet {
        static instance: ScriptWriteSet = ScriptWriteSet {
            execute_as: ::std::string::String::new(),
            script: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ScriptWriteSet {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ScriptWriteSet").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ScriptWriteSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScriptWriteSet {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:DirectWriteSet)
pub struct DirectWriteSet {
    // message fields
    // @@protoc_insertion_point(field:DirectWriteSet.write_set_change)
    pub write_set_change: ::std::vec::Vec<WriteSetChange>,
    // @@protoc_insertion_point(field:DirectWriteSet.events)
    pub events: ::std::vec::Vec<Event>,
    // special fields
    // @@protoc_insertion_point(special_field:DirectWriteSet.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DirectWriteSet {
    fn default() -> &'a DirectWriteSet {
        <DirectWriteSet as ::protobuf::Message>::default_instance()
    }
}

impl DirectWriteSet {
    pub fn new() -> DirectWriteSet {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "write_set_change",
            |m: &DirectWriteSet| { &m.write_set_change },
            |m: &mut DirectWriteSet| { &mut m.write_set_change },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "events",
            |m: &DirectWriteSet| { &m.events },
            |m: &mut DirectWriteSet| { &mut m.events },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DirectWriteSet>(
            "DirectWriteSet",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DirectWriteSet {
    const NAME: &'static str = "DirectWriteSet";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.write_set_change.push(is.read_message()?);
                },
                18 => {
                    self.events.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.write_set_change {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.events {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.write_set_change {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.events {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DirectWriteSet {
        DirectWriteSet::new()
    }

    fn clear(&mut self) {
        self.write_set_change.clear();
        self.events.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DirectWriteSet {
        static instance: DirectWriteSet = DirectWriteSet {
            write_set_change: ::std::vec::Vec::new(),
            events: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DirectWriteSet {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DirectWriteSet").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DirectWriteSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DirectWriteSet {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:WriteSetChange)
pub struct WriteSetChange {
    // message fields
    // @@protoc_insertion_point(field:WriteSetChange.type)
    pub type_: ::protobuf::EnumOrUnknown<write_set_change::WriteSetChangeType>,
    // message oneof groups
    pub change: ::std::option::Option<write_set_change::Change>,
    // special fields
    // @@protoc_insertion_point(special_field:WriteSetChange.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WriteSetChange {
    fn default() -> &'a WriteSetChange {
        <WriteSetChange as ::protobuf::Message>::default_instance()
    }
}

impl WriteSetChange {
    pub fn new() -> WriteSetChange {
        ::std::default::Default::default()
    }

    // .DeleteModule delete_module = 2;

    pub fn delete_module(&self) -> &DeleteModule {
        match self.change {
            ::std::option::Option::Some(write_set_change::Change::DeleteModule(ref v)) => v,
            _ => <DeleteModule as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_delete_module(&mut self) {
        self.change = ::std::option::Option::None;
    }

    pub fn has_delete_module(&self) -> bool {
        match self.change {
            ::std::option::Option::Some(write_set_change::Change::DeleteModule(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_delete_module(&mut self, v: DeleteModule) {
        self.change = ::std::option::Option::Some(write_set_change::Change::DeleteModule(v))
    }

    // Mutable pointer to the field.
    pub fn mut_delete_module(&mut self) -> &mut DeleteModule {
        if let ::std::option::Option::Some(write_set_change::Change::DeleteModule(_)) = self.change {
        } else {
            self.change = ::std::option::Option::Some(write_set_change::Change::DeleteModule(DeleteModule::new()));
        }
        match self.change {
            ::std::option::Option::Some(write_set_change::Change::DeleteModule(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_delete_module(&mut self) -> DeleteModule {
        if self.has_delete_module() {
            match self.change.take() {
                ::std::option::Option::Some(write_set_change::Change::DeleteModule(v)) => v,
                _ => panic!(),
            }
        } else {
            DeleteModule::new()
        }
    }

    // .DeleteResource delete_resource = 3;

    pub fn delete_resource(&self) -> &DeleteResource {
        match self.change {
            ::std::option::Option::Some(write_set_change::Change::DeleteResource(ref v)) => v,
            _ => <DeleteResource as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_delete_resource(&mut self) {
        self.change = ::std::option::Option::None;
    }

    pub fn has_delete_resource(&self) -> bool {
        match self.change {
            ::std::option::Option::Some(write_set_change::Change::DeleteResource(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_delete_resource(&mut self, v: DeleteResource) {
        self.change = ::std::option::Option::Some(write_set_change::Change::DeleteResource(v))
    }

    // Mutable pointer to the field.
    pub fn mut_delete_resource(&mut self) -> &mut DeleteResource {
        if let ::std::option::Option::Some(write_set_change::Change::DeleteResource(_)) = self.change {
        } else {
            self.change = ::std::option::Option::Some(write_set_change::Change::DeleteResource(DeleteResource::new()));
        }
        match self.change {
            ::std::option::Option::Some(write_set_change::Change::DeleteResource(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_delete_resource(&mut self) -> DeleteResource {
        if self.has_delete_resource() {
            match self.change.take() {
                ::std::option::Option::Some(write_set_change::Change::DeleteResource(v)) => v,
                _ => panic!(),
            }
        } else {
            DeleteResource::new()
        }
    }

    // .DeleteTableItem delete_table_item = 4;

    pub fn delete_table_item(&self) -> &DeleteTableItem {
        match self.change {
            ::std::option::Option::Some(write_set_change::Change::DeleteTableItem(ref v)) => v,
            _ => <DeleteTableItem as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_delete_table_item(&mut self) {
        self.change = ::std::option::Option::None;
    }

    pub fn has_delete_table_item(&self) -> bool {
        match self.change {
            ::std::option::Option::Some(write_set_change::Change::DeleteTableItem(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_delete_table_item(&mut self, v: DeleteTableItem) {
        self.change = ::std::option::Option::Some(write_set_change::Change::DeleteTableItem(v))
    }

    // Mutable pointer to the field.
    pub fn mut_delete_table_item(&mut self) -> &mut DeleteTableItem {
        if let ::std::option::Option::Some(write_set_change::Change::DeleteTableItem(_)) = self.change {
        } else {
            self.change = ::std::option::Option::Some(write_set_change::Change::DeleteTableItem(DeleteTableItem::new()));
        }
        match self.change {
            ::std::option::Option::Some(write_set_change::Change::DeleteTableItem(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_delete_table_item(&mut self) -> DeleteTableItem {
        if self.has_delete_table_item() {
            match self.change.take() {
                ::std::option::Option::Some(write_set_change::Change::DeleteTableItem(v)) => v,
                _ => panic!(),
            }
        } else {
            DeleteTableItem::new()
        }
    }

    // .WriteModule write_module = 5;

    pub fn write_module(&self) -> &WriteModule {
        match self.change {
            ::std::option::Option::Some(write_set_change::Change::WriteModule(ref v)) => v,
            _ => <WriteModule as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_write_module(&mut self) {
        self.change = ::std::option::Option::None;
    }

    pub fn has_write_module(&self) -> bool {
        match self.change {
            ::std::option::Option::Some(write_set_change::Change::WriteModule(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_write_module(&mut self, v: WriteModule) {
        self.change = ::std::option::Option::Some(write_set_change::Change::WriteModule(v))
    }

    // Mutable pointer to the field.
    pub fn mut_write_module(&mut self) -> &mut WriteModule {
        if let ::std::option::Option::Some(write_set_change::Change::WriteModule(_)) = self.change {
        } else {
            self.change = ::std::option::Option::Some(write_set_change::Change::WriteModule(WriteModule::new()));
        }
        match self.change {
            ::std::option::Option::Some(write_set_change::Change::WriteModule(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_write_module(&mut self) -> WriteModule {
        if self.has_write_module() {
            match self.change.take() {
                ::std::option::Option::Some(write_set_change::Change::WriteModule(v)) => v,
                _ => panic!(),
            }
        } else {
            WriteModule::new()
        }
    }

    // .WriteResource write_resource = 6;

    pub fn write_resource(&self) -> &WriteResource {
        match self.change {
            ::std::option::Option::Some(write_set_change::Change::WriteResource(ref v)) => v,
            _ => <WriteResource as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_write_resource(&mut self) {
        self.change = ::std::option::Option::None;
    }

    pub fn has_write_resource(&self) -> bool {
        match self.change {
            ::std::option::Option::Some(write_set_change::Change::WriteResource(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_write_resource(&mut self, v: WriteResource) {
        self.change = ::std::option::Option::Some(write_set_change::Change::WriteResource(v))
    }

    // Mutable pointer to the field.
    pub fn mut_write_resource(&mut self) -> &mut WriteResource {
        if let ::std::option::Option::Some(write_set_change::Change::WriteResource(_)) = self.change {
        } else {
            self.change = ::std::option::Option::Some(write_set_change::Change::WriteResource(WriteResource::new()));
        }
        match self.change {
            ::std::option::Option::Some(write_set_change::Change::WriteResource(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_write_resource(&mut self) -> WriteResource {
        if self.has_write_resource() {
            match self.change.take() {
                ::std::option::Option::Some(write_set_change::Change::WriteResource(v)) => v,
                _ => panic!(),
            }
        } else {
            WriteResource::new()
        }
    }

    // .WriteTableItem write_table_item = 7;

    pub fn write_table_item(&self) -> &WriteTableItem {
        match self.change {
            ::std::option::Option::Some(write_set_change::Change::WriteTableItem(ref v)) => v,
            _ => <WriteTableItem as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_write_table_item(&mut self) {
        self.change = ::std::option::Option::None;
    }

    pub fn has_write_table_item(&self) -> bool {
        match self.change {
            ::std::option::Option::Some(write_set_change::Change::WriteTableItem(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_write_table_item(&mut self, v: WriteTableItem) {
        self.change = ::std::option::Option::Some(write_set_change::Change::WriteTableItem(v))
    }

    // Mutable pointer to the field.
    pub fn mut_write_table_item(&mut self) -> &mut WriteTableItem {
        if let ::std::option::Option::Some(write_set_change::Change::WriteTableItem(_)) = self.change {
        } else {
            self.change = ::std::option::Option::Some(write_set_change::Change::WriteTableItem(WriteTableItem::new()));
        }
        match self.change {
            ::std::option::Option::Some(write_set_change::Change::WriteTableItem(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_write_table_item(&mut self) -> WriteTableItem {
        if self.has_write_table_item() {
            match self.change.take() {
                ::std::option::Option::Some(write_set_change::Change::WriteTableItem(v)) => v,
                _ => panic!(),
            }
        } else {
            WriteTableItem::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &WriteSetChange| { &m.type_ },
            |m: &mut WriteSetChange| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, DeleteModule>(
            "delete_module",
            WriteSetChange::has_delete_module,
            WriteSetChange::delete_module,
            WriteSetChange::mut_delete_module,
            WriteSetChange::set_delete_module,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, DeleteResource>(
            "delete_resource",
            WriteSetChange::has_delete_resource,
            WriteSetChange::delete_resource,
            WriteSetChange::mut_delete_resource,
            WriteSetChange::set_delete_resource,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, DeleteTableItem>(
            "delete_table_item",
            WriteSetChange::has_delete_table_item,
            WriteSetChange::delete_table_item,
            WriteSetChange::mut_delete_table_item,
            WriteSetChange::set_delete_table_item,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, WriteModule>(
            "write_module",
            WriteSetChange::has_write_module,
            WriteSetChange::write_module,
            WriteSetChange::mut_write_module,
            WriteSetChange::set_write_module,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, WriteResource>(
            "write_resource",
            WriteSetChange::has_write_resource,
            WriteSetChange::write_resource,
            WriteSetChange::mut_write_resource,
            WriteSetChange::set_write_resource,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, WriteTableItem>(
            "write_table_item",
            WriteSetChange::has_write_table_item,
            WriteSetChange::write_table_item,
            WriteSetChange::mut_write_table_item,
            WriteSetChange::set_write_table_item,
        ));
        oneofs.push(write_set_change::Change::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WriteSetChange>(
            "WriteSetChange",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WriteSetChange {
    const NAME: &'static str = "WriteSetChange";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.change = ::std::option::Option::Some(write_set_change::Change::DeleteModule(is.read_message()?));
                },
                26 => {
                    self.change = ::std::option::Option::Some(write_set_change::Change::DeleteResource(is.read_message()?));
                },
                34 => {
                    self.change = ::std::option::Option::Some(write_set_change::Change::DeleteTableItem(is.read_message()?));
                },
                42 => {
                    self.change = ::std::option::Option::Some(write_set_change::Change::WriteModule(is.read_message()?));
                },
                50 => {
                    self.change = ::std::option::Option::Some(write_set_change::Change::WriteResource(is.read_message()?));
                },
                58 => {
                    self.change = ::std::option::Option::Some(write_set_change::Change::WriteTableItem(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.type_ != ::protobuf::EnumOrUnknown::new(write_set_change::WriteSetChangeType::DELETE_MODULE) {
            my_size += ::protobuf::rt::int32_size(1, self.type_.value());
        }
        if let ::std::option::Option::Some(ref v) = self.change {
            match v {
                &write_set_change::Change::DeleteModule(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &write_set_change::Change::DeleteResource(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &write_set_change::Change::DeleteTableItem(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &write_set_change::Change::WriteModule(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &write_set_change::Change::WriteResource(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &write_set_change::Change::WriteTableItem(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.type_ != ::protobuf::EnumOrUnknown::new(write_set_change::WriteSetChangeType::DELETE_MODULE) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        if let ::std::option::Option::Some(ref v) = self.change {
            match v {
                &write_set_change::Change::DeleteModule(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &write_set_change::Change::DeleteResource(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &write_set_change::Change::DeleteTableItem(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &write_set_change::Change::WriteModule(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
                &write_set_change::Change::WriteResource(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                },
                &write_set_change::Change::WriteTableItem(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WriteSetChange {
        WriteSetChange::new()
    }

    fn clear(&mut self) {
        self.type_ = ::protobuf::EnumOrUnknown::new(write_set_change::WriteSetChangeType::DELETE_MODULE);
        self.change = ::std::option::Option::None;
        self.change = ::std::option::Option::None;
        self.change = ::std::option::Option::None;
        self.change = ::std::option::Option::None;
        self.change = ::std::option::Option::None;
        self.change = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WriteSetChange {
        static instance: WriteSetChange = WriteSetChange {
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            change: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WriteSetChange {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WriteSetChange").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WriteSetChange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WriteSetChange {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `WriteSetChange`
pub mod write_set_change {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:WriteSetChange.change)
    pub enum Change {
        // @@protoc_insertion_point(oneof_field:WriteSetChange.delete_module)
        DeleteModule(super::DeleteModule),
        // @@protoc_insertion_point(oneof_field:WriteSetChange.delete_resource)
        DeleteResource(super::DeleteResource),
        // @@protoc_insertion_point(oneof_field:WriteSetChange.delete_table_item)
        DeleteTableItem(super::DeleteTableItem),
        // @@protoc_insertion_point(oneof_field:WriteSetChange.write_module)
        WriteModule(super::WriteModule),
        // @@protoc_insertion_point(oneof_field:WriteSetChange.write_resource)
        WriteResource(super::WriteResource),
        // @@protoc_insertion_point(oneof_field:WriteSetChange.write_table_item)
        WriteTableItem(super::WriteTableItem),
    }

    impl ::protobuf::Oneof for Change {
    }

    impl ::protobuf::OneofFull for Change {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::WriteSetChange as ::protobuf::MessageFull>::descriptor().oneof_by_name("change").unwrap()).clone()
        }
    }

    impl Change {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Change>("change")
        }
    }
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:WriteSetChange.WriteSetChangeType)
    pub enum WriteSetChangeType {
        // @@protoc_insertion_point(enum_value:WriteSetChange.WriteSetChangeType.DELETE_MODULE)
        DELETE_MODULE = 0,
        // @@protoc_insertion_point(enum_value:WriteSetChange.WriteSetChangeType.DELETE_RESOURCE)
        DELETE_RESOURCE = 1,
        // @@protoc_insertion_point(enum_value:WriteSetChange.WriteSetChangeType.DELETE_TABLE_ITEM)
        DELETE_TABLE_ITEM = 2,
        // @@protoc_insertion_point(enum_value:WriteSetChange.WriteSetChangeType.WRITE_MODULE)
        WRITE_MODULE = 3,
        // @@protoc_insertion_point(enum_value:WriteSetChange.WriteSetChangeType.WRITE_RESOURCE)
        WRITE_RESOURCE = 4,
        // @@protoc_insertion_point(enum_value:WriteSetChange.WriteSetChangeType.WRITE_TABLE_ITEM)
        WRITE_TABLE_ITEM = 5,
    }

    impl ::protobuf::Enum for WriteSetChangeType {
        const NAME: &'static str = "WriteSetChangeType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<WriteSetChangeType> {
            match value {
                0 => ::std::option::Option::Some(WriteSetChangeType::DELETE_MODULE),
                1 => ::std::option::Option::Some(WriteSetChangeType::DELETE_RESOURCE),
                2 => ::std::option::Option::Some(WriteSetChangeType::DELETE_TABLE_ITEM),
                3 => ::std::option::Option::Some(WriteSetChangeType::WRITE_MODULE),
                4 => ::std::option::Option::Some(WriteSetChangeType::WRITE_RESOURCE),
                5 => ::std::option::Option::Some(WriteSetChangeType::WRITE_TABLE_ITEM),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [WriteSetChangeType] = &[
            WriteSetChangeType::DELETE_MODULE,
            WriteSetChangeType::DELETE_RESOURCE,
            WriteSetChangeType::DELETE_TABLE_ITEM,
            WriteSetChangeType::WRITE_MODULE,
            WriteSetChangeType::WRITE_RESOURCE,
            WriteSetChangeType::WRITE_TABLE_ITEM,
        ];
    }

    impl ::protobuf::EnumFull for WriteSetChangeType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("WriteSetChange.WriteSetChangeType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for WriteSetChangeType {
        fn default() -> Self {
            WriteSetChangeType::DELETE_MODULE
        }
    }

    impl WriteSetChangeType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<WriteSetChangeType>("WriteSetChange.WriteSetChangeType")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:DeleteModule)
pub struct DeleteModule {
    // message fields
    // @@protoc_insertion_point(field:DeleteModule.address)
    pub address: ::std::string::String,
    // @@protoc_insertion_point(field:DeleteModule.state_key_hash)
    pub state_key_hash: ::std::string::String,
    // @@protoc_insertion_point(field:DeleteModule.module)
    pub module: ::protobuf::MessageField<MoveModuleId>,
    // special fields
    // @@protoc_insertion_point(special_field:DeleteModule.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteModule {
    fn default() -> &'a DeleteModule {
        <DeleteModule as ::protobuf::Message>::default_instance()
    }
}

impl DeleteModule {
    pub fn new() -> DeleteModule {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &DeleteModule| { &m.address },
            |m: &mut DeleteModule| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "state_key_hash",
            |m: &DeleteModule| { &m.state_key_hash },
            |m: &mut DeleteModule| { &mut m.state_key_hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MoveModuleId>(
            "module",
            |m: &DeleteModule| { &m.module },
            |m: &mut DeleteModule| { &mut m.module },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteModule>(
            "DeleteModule",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteModule {
    const NAME: &'static str = "DeleteModule";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.address = is.read_string()?;
                },
                18 => {
                    self.state_key_hash = is.read_string()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.module)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        if !self.state_key_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.state_key_hash);
        }
        if let Some(v) = self.module.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        if !self.state_key_hash.is_empty() {
            os.write_string(2, &self.state_key_hash)?;
        }
        if let Some(v) = self.module.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteModule {
        DeleteModule::new()
    }

    fn clear(&mut self) {
        self.address.clear();
        self.state_key_hash.clear();
        self.module.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteModule {
        static instance: DeleteModule = DeleteModule {
            address: ::std::string::String::new(),
            state_key_hash: ::std::string::String::new(),
            module: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteModule {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteModule").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteModule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteModule {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:DeleteResource)
pub struct DeleteResource {
    // message fields
    // @@protoc_insertion_point(field:DeleteResource.address)
    pub address: ::std::string::String,
    // @@protoc_insertion_point(field:DeleteResource.state_key_hash)
    pub state_key_hash: ::std::string::String,
    // @@protoc_insertion_point(field:DeleteResource.resource)
    pub resource: ::protobuf::MessageField<MoveStructTag>,
    // special fields
    // @@protoc_insertion_point(special_field:DeleteResource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteResource {
    fn default() -> &'a DeleteResource {
        <DeleteResource as ::protobuf::Message>::default_instance()
    }
}

impl DeleteResource {
    pub fn new() -> DeleteResource {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &DeleteResource| { &m.address },
            |m: &mut DeleteResource| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "state_key_hash",
            |m: &DeleteResource| { &m.state_key_hash },
            |m: &mut DeleteResource| { &mut m.state_key_hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MoveStructTag>(
            "resource",
            |m: &DeleteResource| { &m.resource },
            |m: &mut DeleteResource| { &mut m.resource },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteResource>(
            "DeleteResource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteResource {
    const NAME: &'static str = "DeleteResource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.address = is.read_string()?;
                },
                18 => {
                    self.state_key_hash = is.read_string()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.resource)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        if !self.state_key_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.state_key_hash);
        }
        if let Some(v) = self.resource.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        if !self.state_key_hash.is_empty() {
            os.write_string(2, &self.state_key_hash)?;
        }
        if let Some(v) = self.resource.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteResource {
        DeleteResource::new()
    }

    fn clear(&mut self) {
        self.address.clear();
        self.state_key_hash.clear();
        self.resource.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteResource {
        static instance: DeleteResource = DeleteResource {
            address: ::std::string::String::new(),
            state_key_hash: ::std::string::String::new(),
            resource: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteResource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteResource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteResource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteResource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:DeleteTableItem)
pub struct DeleteTableItem {
    // message fields
    // @@protoc_insertion_point(field:DeleteTableItem.state_key_hash)
    pub state_key_hash: ::std::string::String,
    // @@protoc_insertion_point(field:DeleteTableItem.handle)
    pub handle: ::std::string::String,
    // @@protoc_insertion_point(field:DeleteTableItem.key)
    pub key: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:DeleteTableItem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteTableItem {
    fn default() -> &'a DeleteTableItem {
        <DeleteTableItem as ::protobuf::Message>::default_instance()
    }
}

impl DeleteTableItem {
    pub fn new() -> DeleteTableItem {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "state_key_hash",
            |m: &DeleteTableItem| { &m.state_key_hash },
            |m: &mut DeleteTableItem| { &mut m.state_key_hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "handle",
            |m: &DeleteTableItem| { &m.handle },
            |m: &mut DeleteTableItem| { &mut m.handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &DeleteTableItem| { &m.key },
            |m: &mut DeleteTableItem| { &mut m.key },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteTableItem>(
            "DeleteTableItem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteTableItem {
    const NAME: &'static str = "DeleteTableItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.state_key_hash = is.read_string()?;
                },
                18 => {
                    self.handle = is.read_string()?;
                },
                26 => {
                    self.key = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.state_key_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.state_key_hash);
        }
        if !self.handle.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.handle);
        }
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.key);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.state_key_hash.is_empty() {
            os.write_string(1, &self.state_key_hash)?;
        }
        if !self.handle.is_empty() {
            os.write_string(2, &self.handle)?;
        }
        if !self.key.is_empty() {
            os.write_string(3, &self.key)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteTableItem {
        DeleteTableItem::new()
    }

    fn clear(&mut self) {
        self.state_key_hash.clear();
        self.handle.clear();
        self.key.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteTableItem {
        static instance: DeleteTableItem = DeleteTableItem {
            state_key_hash: ::std::string::String::new(),
            handle: ::std::string::String::new(),
            key: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteTableItem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteTableItem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteTableItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteTableItem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:WriteModule)
pub struct WriteModule {
    // message fields
    // @@protoc_insertion_point(field:WriteModule.address)
    pub address: ::std::string::String,
    // @@protoc_insertion_point(field:WriteModule.state_key_hash)
    pub state_key_hash: ::std::string::String,
    // @@protoc_insertion_point(field:WriteModule.data)
    pub data: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:WriteModule.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WriteModule {
    fn default() -> &'a WriteModule {
        <WriteModule as ::protobuf::Message>::default_instance()
    }
}

impl WriteModule {
    pub fn new() -> WriteModule {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &WriteModule| { &m.address },
            |m: &mut WriteModule| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "state_key_hash",
            |m: &WriteModule| { &m.state_key_hash },
            |m: &mut WriteModule| { &mut m.state_key_hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data",
            |m: &WriteModule| { &m.data },
            |m: &mut WriteModule| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WriteModule>(
            "WriteModule",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WriteModule {
    const NAME: &'static str = "WriteModule";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.address = is.read_string()?;
                },
                18 => {
                    self.state_key_hash = is.read_string()?;
                },
                26 => {
                    self.data = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        if !self.state_key_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.state_key_hash);
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        if !self.state_key_hash.is_empty() {
            os.write_string(2, &self.state_key_hash)?;
        }
        if !self.data.is_empty() {
            os.write_string(3, &self.data)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WriteModule {
        WriteModule::new()
    }

    fn clear(&mut self) {
        self.address.clear();
        self.state_key_hash.clear();
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WriteModule {
        static instance: WriteModule = WriteModule {
            address: ::std::string::String::new(),
            state_key_hash: ::std::string::String::new(),
            data: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WriteModule {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WriteModule").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WriteModule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WriteModule {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:WriteResource)
pub struct WriteResource {
    // message fields
    // @@protoc_insertion_point(field:WriteResource.address)
    pub address: ::std::string::String,
    // @@protoc_insertion_point(field:WriteResource.state_key_hash)
    pub state_key_hash: ::std::string::String,
    // @@protoc_insertion_point(field:WriteResource.data)
    pub data: ::protobuf::MessageField<MoveResource>,
    // special fields
    // @@protoc_insertion_point(special_field:WriteResource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WriteResource {
    fn default() -> &'a WriteResource {
        <WriteResource as ::protobuf::Message>::default_instance()
    }
}

impl WriteResource {
    pub fn new() -> WriteResource {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &WriteResource| { &m.address },
            |m: &mut WriteResource| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "state_key_hash",
            |m: &WriteResource| { &m.state_key_hash },
            |m: &mut WriteResource| { &mut m.state_key_hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MoveResource>(
            "data",
            |m: &WriteResource| { &m.data },
            |m: &mut WriteResource| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WriteResource>(
            "WriteResource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WriteResource {
    const NAME: &'static str = "WriteResource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.address = is.read_string()?;
                },
                18 => {
                    self.state_key_hash = is.read_string()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        if !self.state_key_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.state_key_hash);
        }
        if let Some(v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        if !self.state_key_hash.is_empty() {
            os.write_string(2, &self.state_key_hash)?;
        }
        if let Some(v) = self.data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WriteResource {
        WriteResource::new()
    }

    fn clear(&mut self) {
        self.address.clear();
        self.state_key_hash.clear();
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WriteResource {
        static instance: WriteResource = WriteResource {
            address: ::std::string::String::new(),
            state_key_hash: ::std::string::String::new(),
            data: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WriteResource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WriteResource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WriteResource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WriteResource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:WriteTableItem)
pub struct WriteTableItem {
    // message fields
    // @@protoc_insertion_point(field:WriteTableItem.state_key_hash)
    pub state_key_hash: ::std::string::String,
    // @@protoc_insertion_point(field:WriteTableItem.handle)
    pub handle: ::std::string::String,
    // @@protoc_insertion_point(field:WriteTableItem.key)
    pub key: ::std::string::String,
    // @@protoc_insertion_point(field:WriteTableItem.value)
    pub value: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:WriteTableItem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WriteTableItem {
    fn default() -> &'a WriteTableItem {
        <WriteTableItem as ::protobuf::Message>::default_instance()
    }
}

impl WriteTableItem {
    pub fn new() -> WriteTableItem {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "state_key_hash",
            |m: &WriteTableItem| { &m.state_key_hash },
            |m: &mut WriteTableItem| { &mut m.state_key_hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "handle",
            |m: &WriteTableItem| { &m.handle },
            |m: &mut WriteTableItem| { &mut m.handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &WriteTableItem| { &m.key },
            |m: &mut WriteTableItem| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "value",
            |m: &WriteTableItem| { &m.value },
            |m: &mut WriteTableItem| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WriteTableItem>(
            "WriteTableItem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WriteTableItem {
    const NAME: &'static str = "WriteTableItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.state_key_hash = is.read_string()?;
                },
                18 => {
                    self.handle = is.read_string()?;
                },
                26 => {
                    self.key = is.read_string()?;
                },
                34 => {
                    self.value = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.state_key_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.state_key_hash);
        }
        if !self.handle.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.handle);
        }
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.key);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.state_key_hash.is_empty() {
            os.write_string(1, &self.state_key_hash)?;
        }
        if !self.handle.is_empty() {
            os.write_string(2, &self.handle)?;
        }
        if !self.key.is_empty() {
            os.write_string(3, &self.key)?;
        }
        if !self.value.is_empty() {
            os.write_string(4, &self.value)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WriteTableItem {
        WriteTableItem::new()
    }

    fn clear(&mut self) {
        self.state_key_hash.clear();
        self.handle.clear();
        self.key.clear();
        self.value.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WriteTableItem {
        static instance: WriteTableItem = WriteTableItem {
            state_key_hash: ::std::string::String::new(),
            handle: ::std::string::String::new(),
            key: ::std::string::String::new(),
            value: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WriteTableItem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WriteTableItem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WriteTableItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WriteTableItem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:TransactionPayload)
pub struct TransactionPayload {
    // message fields
    // @@protoc_insertion_point(field:TransactionPayload.type)
    pub type_: ::protobuf::EnumOrUnknown<transaction_payload::PayloadType>,
    // message oneof groups
    pub payload: ::std::option::Option<transaction_payload::Payload>,
    // special fields
    // @@protoc_insertion_point(special_field:TransactionPayload.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TransactionPayload {
    fn default() -> &'a TransactionPayload {
        <TransactionPayload as ::protobuf::Message>::default_instance()
    }
}

impl TransactionPayload {
    pub fn new() -> TransactionPayload {
        ::std::default::Default::default()
    }

    // .ScriptFunctionPayload script_function_payload = 2;

    pub fn script_function_payload(&self) -> &ScriptFunctionPayload {
        match self.payload {
            ::std::option::Option::Some(transaction_payload::Payload::ScriptFunctionPayload(ref v)) => v,
            _ => <ScriptFunctionPayload as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_script_function_payload(&mut self) {
        self.payload = ::std::option::Option::None;
    }

    pub fn has_script_function_payload(&self) -> bool {
        match self.payload {
            ::std::option::Option::Some(transaction_payload::Payload::ScriptFunctionPayload(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_script_function_payload(&mut self, v: ScriptFunctionPayload) {
        self.payload = ::std::option::Option::Some(transaction_payload::Payload::ScriptFunctionPayload(v))
    }

    // Mutable pointer to the field.
    pub fn mut_script_function_payload(&mut self) -> &mut ScriptFunctionPayload {
        if let ::std::option::Option::Some(transaction_payload::Payload::ScriptFunctionPayload(_)) = self.payload {
        } else {
            self.payload = ::std::option::Option::Some(transaction_payload::Payload::ScriptFunctionPayload(ScriptFunctionPayload::new()));
        }
        match self.payload {
            ::std::option::Option::Some(transaction_payload::Payload::ScriptFunctionPayload(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_script_function_payload(&mut self) -> ScriptFunctionPayload {
        if self.has_script_function_payload() {
            match self.payload.take() {
                ::std::option::Option::Some(transaction_payload::Payload::ScriptFunctionPayload(v)) => v,
                _ => panic!(),
            }
        } else {
            ScriptFunctionPayload::new()
        }
    }

    // .ScriptPayload script_payload = 3;

    pub fn script_payload(&self) -> &ScriptPayload {
        match self.payload {
            ::std::option::Option::Some(transaction_payload::Payload::ScriptPayload(ref v)) => v,
            _ => <ScriptPayload as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_script_payload(&mut self) {
        self.payload = ::std::option::Option::None;
    }

    pub fn has_script_payload(&self) -> bool {
        match self.payload {
            ::std::option::Option::Some(transaction_payload::Payload::ScriptPayload(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_script_payload(&mut self, v: ScriptPayload) {
        self.payload = ::std::option::Option::Some(transaction_payload::Payload::ScriptPayload(v))
    }

    // Mutable pointer to the field.
    pub fn mut_script_payload(&mut self) -> &mut ScriptPayload {
        if let ::std::option::Option::Some(transaction_payload::Payload::ScriptPayload(_)) = self.payload {
        } else {
            self.payload = ::std::option::Option::Some(transaction_payload::Payload::ScriptPayload(ScriptPayload::new()));
        }
        match self.payload {
            ::std::option::Option::Some(transaction_payload::Payload::ScriptPayload(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_script_payload(&mut self) -> ScriptPayload {
        if self.has_script_payload() {
            match self.payload.take() {
                ::std::option::Option::Some(transaction_payload::Payload::ScriptPayload(v)) => v,
                _ => panic!(),
            }
        } else {
            ScriptPayload::new()
        }
    }

    // .ModuleBundlePayload module_bundle_payload = 4;

    pub fn module_bundle_payload(&self) -> &ModuleBundlePayload {
        match self.payload {
            ::std::option::Option::Some(transaction_payload::Payload::ModuleBundlePayload(ref v)) => v,
            _ => <ModuleBundlePayload as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_module_bundle_payload(&mut self) {
        self.payload = ::std::option::Option::None;
    }

    pub fn has_module_bundle_payload(&self) -> bool {
        match self.payload {
            ::std::option::Option::Some(transaction_payload::Payload::ModuleBundlePayload(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_module_bundle_payload(&mut self, v: ModuleBundlePayload) {
        self.payload = ::std::option::Option::Some(transaction_payload::Payload::ModuleBundlePayload(v))
    }

    // Mutable pointer to the field.
    pub fn mut_module_bundle_payload(&mut self) -> &mut ModuleBundlePayload {
        if let ::std::option::Option::Some(transaction_payload::Payload::ModuleBundlePayload(_)) = self.payload {
        } else {
            self.payload = ::std::option::Option::Some(transaction_payload::Payload::ModuleBundlePayload(ModuleBundlePayload::new()));
        }
        match self.payload {
            ::std::option::Option::Some(transaction_payload::Payload::ModuleBundlePayload(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_module_bundle_payload(&mut self) -> ModuleBundlePayload {
        if self.has_module_bundle_payload() {
            match self.payload.take() {
                ::std::option::Option::Some(transaction_payload::Payload::ModuleBundlePayload(v)) => v,
                _ => panic!(),
            }
        } else {
            ModuleBundlePayload::new()
        }
    }

    // .WriteSetPayload write_set_payload = 5;

    pub fn write_set_payload(&self) -> &WriteSetPayload {
        match self.payload {
            ::std::option::Option::Some(transaction_payload::Payload::WriteSetPayload(ref v)) => v,
            _ => <WriteSetPayload as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_write_set_payload(&mut self) {
        self.payload = ::std::option::Option::None;
    }

    pub fn has_write_set_payload(&self) -> bool {
        match self.payload {
            ::std::option::Option::Some(transaction_payload::Payload::WriteSetPayload(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_write_set_payload(&mut self, v: WriteSetPayload) {
        self.payload = ::std::option::Option::Some(transaction_payload::Payload::WriteSetPayload(v))
    }

    // Mutable pointer to the field.
    pub fn mut_write_set_payload(&mut self) -> &mut WriteSetPayload {
        if let ::std::option::Option::Some(transaction_payload::Payload::WriteSetPayload(_)) = self.payload {
        } else {
            self.payload = ::std::option::Option::Some(transaction_payload::Payload::WriteSetPayload(WriteSetPayload::new()));
        }
        match self.payload {
            ::std::option::Option::Some(transaction_payload::Payload::WriteSetPayload(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_write_set_payload(&mut self) -> WriteSetPayload {
        if self.has_write_set_payload() {
            match self.payload.take() {
                ::std::option::Option::Some(transaction_payload::Payload::WriteSetPayload(v)) => v,
                _ => panic!(),
            }
        } else {
            WriteSetPayload::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &TransactionPayload| { &m.type_ },
            |m: &mut TransactionPayload| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ScriptFunctionPayload>(
            "script_function_payload",
            TransactionPayload::has_script_function_payload,
            TransactionPayload::script_function_payload,
            TransactionPayload::mut_script_function_payload,
            TransactionPayload::set_script_function_payload,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ScriptPayload>(
            "script_payload",
            TransactionPayload::has_script_payload,
            TransactionPayload::script_payload,
            TransactionPayload::mut_script_payload,
            TransactionPayload::set_script_payload,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ModuleBundlePayload>(
            "module_bundle_payload",
            TransactionPayload::has_module_bundle_payload,
            TransactionPayload::module_bundle_payload,
            TransactionPayload::mut_module_bundle_payload,
            TransactionPayload::set_module_bundle_payload,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, WriteSetPayload>(
            "write_set_payload",
            TransactionPayload::has_write_set_payload,
            TransactionPayload::write_set_payload,
            TransactionPayload::mut_write_set_payload,
            TransactionPayload::set_write_set_payload,
        ));
        oneofs.push(transaction_payload::Payload::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TransactionPayload>(
            "TransactionPayload",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TransactionPayload {
    const NAME: &'static str = "TransactionPayload";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.payload = ::std::option::Option::Some(transaction_payload::Payload::ScriptFunctionPayload(is.read_message()?));
                },
                26 => {
                    self.payload = ::std::option::Option::Some(transaction_payload::Payload::ScriptPayload(is.read_message()?));
                },
                34 => {
                    self.payload = ::std::option::Option::Some(transaction_payload::Payload::ModuleBundlePayload(is.read_message()?));
                },
                42 => {
                    self.payload = ::std::option::Option::Some(transaction_payload::Payload::WriteSetPayload(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.type_ != ::protobuf::EnumOrUnknown::new(transaction_payload::PayloadType::SCRIPT_FUNCTION_PAYLOAD) {
            my_size += ::protobuf::rt::int32_size(1, self.type_.value());
        }
        if let ::std::option::Option::Some(ref v) = self.payload {
            match v {
                &transaction_payload::Payload::ScriptFunctionPayload(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &transaction_payload::Payload::ScriptPayload(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &transaction_payload::Payload::ModuleBundlePayload(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &transaction_payload::Payload::WriteSetPayload(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.type_ != ::protobuf::EnumOrUnknown::new(transaction_payload::PayloadType::SCRIPT_FUNCTION_PAYLOAD) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        if let ::std::option::Option::Some(ref v) = self.payload {
            match v {
                &transaction_payload::Payload::ScriptFunctionPayload(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &transaction_payload::Payload::ScriptPayload(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &transaction_payload::Payload::ModuleBundlePayload(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &transaction_payload::Payload::WriteSetPayload(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TransactionPayload {
        TransactionPayload::new()
    }

    fn clear(&mut self) {
        self.type_ = ::protobuf::EnumOrUnknown::new(transaction_payload::PayloadType::SCRIPT_FUNCTION_PAYLOAD);
        self.payload = ::std::option::Option::None;
        self.payload = ::std::option::Option::None;
        self.payload = ::std::option::Option::None;
        self.payload = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TransactionPayload {
        static instance: TransactionPayload = TransactionPayload {
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            payload: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TransactionPayload {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TransactionPayload").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TransactionPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionPayload {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `TransactionPayload`
pub mod transaction_payload {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:TransactionPayload.payload)
    pub enum Payload {
        // @@protoc_insertion_point(oneof_field:TransactionPayload.script_function_payload)
        ScriptFunctionPayload(super::ScriptFunctionPayload),
        // @@protoc_insertion_point(oneof_field:TransactionPayload.script_payload)
        ScriptPayload(super::ScriptPayload),
        // @@protoc_insertion_point(oneof_field:TransactionPayload.module_bundle_payload)
        ModuleBundlePayload(super::ModuleBundlePayload),
        // @@protoc_insertion_point(oneof_field:TransactionPayload.write_set_payload)
        WriteSetPayload(super::WriteSetPayload),
    }

    impl ::protobuf::Oneof for Payload {
    }

    impl ::protobuf::OneofFull for Payload {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::TransactionPayload as ::protobuf::MessageFull>::descriptor().oneof_by_name("payload").unwrap()).clone()
        }
    }

    impl Payload {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Payload>("payload")
        }
    }
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:TransactionPayload.PayloadType)
    pub enum PayloadType {
        // @@protoc_insertion_point(enum_value:TransactionPayload.PayloadType.SCRIPT_FUNCTION_PAYLOAD)
        SCRIPT_FUNCTION_PAYLOAD = 0,
        // @@protoc_insertion_point(enum_value:TransactionPayload.PayloadType.SCRIPT_PAYLOAD)
        SCRIPT_PAYLOAD = 1,
        // @@protoc_insertion_point(enum_value:TransactionPayload.PayloadType.MODULE_BUNDLE_PAYLOAD)
        MODULE_BUNDLE_PAYLOAD = 2,
        // @@protoc_insertion_point(enum_value:TransactionPayload.PayloadType.WRITE_SET_PAYLOAD)
        WRITE_SET_PAYLOAD = 3,
    }

    impl ::protobuf::Enum for PayloadType {
        const NAME: &'static str = "PayloadType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<PayloadType> {
            match value {
                0 => ::std::option::Option::Some(PayloadType::SCRIPT_FUNCTION_PAYLOAD),
                1 => ::std::option::Option::Some(PayloadType::SCRIPT_PAYLOAD),
                2 => ::std::option::Option::Some(PayloadType::MODULE_BUNDLE_PAYLOAD),
                3 => ::std::option::Option::Some(PayloadType::WRITE_SET_PAYLOAD),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [PayloadType] = &[
            PayloadType::SCRIPT_FUNCTION_PAYLOAD,
            PayloadType::SCRIPT_PAYLOAD,
            PayloadType::MODULE_BUNDLE_PAYLOAD,
            PayloadType::WRITE_SET_PAYLOAD,
        ];
    }

    impl ::protobuf::EnumFull for PayloadType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("TransactionPayload.PayloadType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for PayloadType {
        fn default() -> Self {
            PayloadType::SCRIPT_FUNCTION_PAYLOAD
        }
    }

    impl PayloadType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<PayloadType>("TransactionPayload.PayloadType")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ScriptFunctionPayload)
pub struct ScriptFunctionPayload {
    // message fields
    // @@protoc_insertion_point(field:ScriptFunctionPayload.function)
    pub function: ::protobuf::MessageField<ScriptFunctionId>,
    // @@protoc_insertion_point(field:ScriptFunctionPayload.type_arguments)
    pub type_arguments: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:ScriptFunctionPayload.arguments)
    pub arguments: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:ScriptFunctionPayload.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ScriptFunctionPayload {
    fn default() -> &'a ScriptFunctionPayload {
        <ScriptFunctionPayload as ::protobuf::Message>::default_instance()
    }
}

impl ScriptFunctionPayload {
    pub fn new() -> ScriptFunctionPayload {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ScriptFunctionId>(
            "function",
            |m: &ScriptFunctionPayload| { &m.function },
            |m: &mut ScriptFunctionPayload| { &mut m.function },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "type_arguments",
            |m: &ScriptFunctionPayload| { &m.type_arguments },
            |m: &mut ScriptFunctionPayload| { &mut m.type_arguments },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "arguments",
            |m: &ScriptFunctionPayload| { &m.arguments },
            |m: &mut ScriptFunctionPayload| { &mut m.arguments },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ScriptFunctionPayload>(
            "ScriptFunctionPayload",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ScriptFunctionPayload {
    const NAME: &'static str = "ScriptFunctionPayload";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.function)?;
                },
                18 => {
                    self.type_arguments.push(is.read_string()?);
                },
                26 => {
                    self.arguments.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.function.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.type_arguments {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.arguments {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.function.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.type_arguments {
            os.write_string(2, &v)?;
        };
        for v in &self.arguments {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ScriptFunctionPayload {
        ScriptFunctionPayload::new()
    }

    fn clear(&mut self) {
        self.function.clear();
        self.type_arguments.clear();
        self.arguments.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ScriptFunctionPayload {
        static instance: ScriptFunctionPayload = ScriptFunctionPayload {
            function: ::protobuf::MessageField::none(),
            type_arguments: ::std::vec::Vec::new(),
            arguments: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ScriptFunctionPayload {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ScriptFunctionPayload").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ScriptFunctionPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScriptFunctionPayload {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ScriptPayload)
pub struct ScriptPayload {
    // message fields
    // @@protoc_insertion_point(field:ScriptPayload.code)
    pub code: ::std::string::String,
    // @@protoc_insertion_point(field:ScriptPayload.type_arguments)
    pub type_arguments: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:ScriptPayload.arguments)
    pub arguments: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:ScriptPayload.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ScriptPayload {
    fn default() -> &'a ScriptPayload {
        <ScriptPayload as ::protobuf::Message>::default_instance()
    }
}

impl ScriptPayload {
    pub fn new() -> ScriptPayload {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "code",
            |m: &ScriptPayload| { &m.code },
            |m: &mut ScriptPayload| { &mut m.code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "type_arguments",
            |m: &ScriptPayload| { &m.type_arguments },
            |m: &mut ScriptPayload| { &mut m.type_arguments },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "arguments",
            |m: &ScriptPayload| { &m.arguments },
            |m: &mut ScriptPayload| { &mut m.arguments },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ScriptPayload>(
            "ScriptPayload",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ScriptPayload {
    const NAME: &'static str = "ScriptPayload";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.code = is.read_string()?;
                },
                18 => {
                    self.type_arguments.push(is.read_string()?);
                },
                26 => {
                    self.arguments.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.code.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.code);
        }
        for value in &self.type_arguments {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.arguments {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.code.is_empty() {
            os.write_string(1, &self.code)?;
        }
        for v in &self.type_arguments {
            os.write_string(2, &v)?;
        };
        for v in &self.arguments {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ScriptPayload {
        ScriptPayload::new()
    }

    fn clear(&mut self) {
        self.code.clear();
        self.type_arguments.clear();
        self.arguments.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ScriptPayload {
        static instance: ScriptPayload = ScriptPayload {
            code: ::std::string::String::new(),
            type_arguments: ::std::vec::Vec::new(),
            arguments: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ScriptPayload {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ScriptPayload").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ScriptPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScriptPayload {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ModuleBundlePayload)
pub struct ModuleBundlePayload {
    // message fields
    // @@protoc_insertion_point(field:ModuleBundlePayload.modules)
    pub modules: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:ModuleBundlePayload.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ModuleBundlePayload {
    fn default() -> &'a ModuleBundlePayload {
        <ModuleBundlePayload as ::protobuf::Message>::default_instance()
    }
}

impl ModuleBundlePayload {
    pub fn new() -> ModuleBundlePayload {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "modules",
            |m: &ModuleBundlePayload| { &m.modules },
            |m: &mut ModuleBundlePayload| { &mut m.modules },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ModuleBundlePayload>(
            "ModuleBundlePayload",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ModuleBundlePayload {
    const NAME: &'static str = "ModuleBundlePayload";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.modules.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.modules {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.modules {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ModuleBundlePayload {
        ModuleBundlePayload::new()
    }

    fn clear(&mut self) {
        self.modules.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ModuleBundlePayload {
        static instance: ModuleBundlePayload = ModuleBundlePayload {
            modules: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ModuleBundlePayload {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ModuleBundlePayload").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ModuleBundlePayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModuleBundlePayload {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:WriteSetPayload)
pub struct WriteSetPayload {
    // message fields
    // @@protoc_insertion_point(field:WriteSetPayload.write_set)
    pub write_set: ::protobuf::MessageField<WriteSet>,
    // special fields
    // @@protoc_insertion_point(special_field:WriteSetPayload.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WriteSetPayload {
    fn default() -> &'a WriteSetPayload {
        <WriteSetPayload as ::protobuf::Message>::default_instance()
    }
}

impl WriteSetPayload {
    pub fn new() -> WriteSetPayload {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, WriteSet>(
            "write_set",
            |m: &WriteSetPayload| { &m.write_set },
            |m: &mut WriteSetPayload| { &mut m.write_set },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WriteSetPayload>(
            "WriteSetPayload",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WriteSetPayload {
    const NAME: &'static str = "WriteSetPayload";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.write_set)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.write_set.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.write_set.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WriteSetPayload {
        WriteSetPayload::new()
    }

    fn clear(&mut self) {
        self.write_set.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WriteSetPayload {
        static instance: WriteSetPayload = WriteSetPayload {
            write_set: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WriteSetPayload {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WriteSetPayload").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WriteSetPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WriteSetPayload {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ScriptFunctionId)
pub struct ScriptFunctionId {
    // message fields
    // @@protoc_insertion_point(field:ScriptFunctionId.module)
    pub module: ::protobuf::MessageField<MoveModuleId>,
    // @@protoc_insertion_point(field:ScriptFunctionId.name)
    pub name: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:ScriptFunctionId.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ScriptFunctionId {
    fn default() -> &'a ScriptFunctionId {
        <ScriptFunctionId as ::protobuf::Message>::default_instance()
    }
}

impl ScriptFunctionId {
    pub fn new() -> ScriptFunctionId {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MoveModuleId>(
            "module",
            |m: &ScriptFunctionId| { &m.module },
            |m: &mut ScriptFunctionId| { &mut m.module },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &ScriptFunctionId| { &m.name },
            |m: &mut ScriptFunctionId| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ScriptFunctionId>(
            "ScriptFunctionId",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ScriptFunctionId {
    const NAME: &'static str = "ScriptFunctionId";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.module)?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.module.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.module.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ScriptFunctionId {
        ScriptFunctionId::new()
    }

    fn clear(&mut self) {
        self.module.clear();
        self.name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ScriptFunctionId {
        static instance: ScriptFunctionId = ScriptFunctionId {
            module: ::protobuf::MessageField::none(),
            name: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ScriptFunctionId {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ScriptFunctionId").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ScriptFunctionId {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScriptFunctionId {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:MoveResource)
pub struct MoveResource {
    // message fields
    // @@protoc_insertion_point(field:MoveResource.type)
    pub type_: ::protobuf::MessageField<MoveStructTag>,
    // @@protoc_insertion_point(field:MoveResource.data)
    pub data: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:MoveResource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoveResource {
    fn default() -> &'a MoveResource {
        <MoveResource as ::protobuf::Message>::default_instance()
    }
}

impl MoveResource {
    pub fn new() -> MoveResource {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MoveStructTag>(
            "type",
            |m: &MoveResource| { &m.type_ },
            |m: &mut MoveResource| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data",
            |m: &MoveResource| { &m.data },
            |m: &mut MoveResource| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoveResource>(
            "MoveResource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoveResource {
    const NAME: &'static str = "MoveResource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.type_)?;
                },
                18 => {
                    self.data = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.data.is_empty() {
            os.write_string(2, &self.data)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoveResource {
        MoveResource::new()
    }

    fn clear(&mut self) {
        self.type_.clear();
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoveResource {
        static instance: MoveResource = MoveResource {
            type_: ::protobuf::MessageField::none(),
            data: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoveResource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoveResource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoveResource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoveResource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:MoveModuleId)
pub struct MoveModuleId {
    // message fields
    // @@protoc_insertion_point(field:MoveModuleId.address)
    pub address: ::std::string::String,
    // @@protoc_insertion_point(field:MoveModuleId.name)
    pub name: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:MoveModuleId.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoveModuleId {
    fn default() -> &'a MoveModuleId {
        <MoveModuleId as ::protobuf::Message>::default_instance()
    }
}

impl MoveModuleId {
    pub fn new() -> MoveModuleId {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &MoveModuleId| { &m.address },
            |m: &mut MoveModuleId| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &MoveModuleId| { &m.name },
            |m: &mut MoveModuleId| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoveModuleId>(
            "MoveModuleId",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoveModuleId {
    const NAME: &'static str = "MoveModuleId";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.address = is.read_string()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoveModuleId {
        MoveModuleId::new()
    }

    fn clear(&mut self) {
        self.address.clear();
        self.name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoveModuleId {
        static instance: MoveModuleId = MoveModuleId {
            address: ::std::string::String::new(),
            name: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoveModuleId {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoveModuleId").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoveModuleId {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoveModuleId {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:MoveStructTag)
pub struct MoveStructTag {
    // message fields
    // @@protoc_insertion_point(field:MoveStructTag.address)
    pub address: ::std::string::String,
    // @@protoc_insertion_point(field:MoveStructTag.module)
    pub module: ::std::string::String,
    // @@protoc_insertion_point(field:MoveStructTag.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:MoveStructTag.generic_type_params)
    pub generic_type_params: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:MoveStructTag.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoveStructTag {
    fn default() -> &'a MoveStructTag {
        <MoveStructTag as ::protobuf::Message>::default_instance()
    }
}

impl MoveStructTag {
    pub fn new() -> MoveStructTag {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &MoveStructTag| { &m.address },
            |m: &mut MoveStructTag| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "module",
            |m: &MoveStructTag| { &m.module },
            |m: &mut MoveStructTag| { &mut m.module },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &MoveStructTag| { &m.name },
            |m: &mut MoveStructTag| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "generic_type_params",
            |m: &MoveStructTag| { &m.generic_type_params },
            |m: &mut MoveStructTag| { &mut m.generic_type_params },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoveStructTag>(
            "MoveStructTag",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoveStructTag {
    const NAME: &'static str = "MoveStructTag";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.address = is.read_string()?;
                },
                18 => {
                    self.module = is.read_string()?;
                },
                26 => {
                    self.name = is.read_string()?;
                },
                34 => {
                    self.generic_type_params.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        if !self.module.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.module);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        for value in &self.generic_type_params {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        if !self.module.is_empty() {
            os.write_string(2, &self.module)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        for v in &self.generic_type_params {
            os.write_string(4, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoveStructTag {
        MoveStructTag::new()
    }

    fn clear(&mut self) {
        self.address.clear();
        self.module.clear();
        self.name.clear();
        self.generic_type_params.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoveStructTag {
        static instance: MoveStructTag = MoveStructTag {
            address: ::std::string::String::new(),
            module: ::std::string::String::new(),
            name: ::std::string::String::new(),
            generic_type_params: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoveStructTag {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoveStructTag").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoveStructTag {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoveStructTag {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:Signature)
pub struct Signature {
    // message fields
    // @@protoc_insertion_point(field:Signature.type)
    pub type_: ::protobuf::EnumOrUnknown<signature::SignatureType>,
    // message oneof groups
    pub signature: ::std::option::Option<signature::Signature>,
    // special fields
    // @@protoc_insertion_point(special_field:Signature.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Signature {
    fn default() -> &'a Signature {
        <Signature as ::protobuf::Message>::default_instance()
    }
}

impl Signature {
    pub fn new() -> Signature {
        ::std::default::Default::default()
    }

    // .Ed25519Signature ed = 2;

    pub fn ed(&self) -> &Ed25519Signature {
        match self.signature {
            ::std::option::Option::Some(signature::Signature::Ed(ref v)) => v,
            _ => <Ed25519Signature as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_ed(&mut self) {
        self.signature = ::std::option::Option::None;
    }

    pub fn has_ed(&self) -> bool {
        match self.signature {
            ::std::option::Option::Some(signature::Signature::Ed(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ed(&mut self, v: Ed25519Signature) {
        self.signature = ::std::option::Option::Some(signature::Signature::Ed(v))
    }

    // Mutable pointer to the field.
    pub fn mut_ed(&mut self) -> &mut Ed25519Signature {
        if let ::std::option::Option::Some(signature::Signature::Ed(_)) = self.signature {
        } else {
            self.signature = ::std::option::Option::Some(signature::Signature::Ed(Ed25519Signature::new()));
        }
        match self.signature {
            ::std::option::Option::Some(signature::Signature::Ed(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_ed(&mut self) -> Ed25519Signature {
        if self.has_ed() {
            match self.signature.take() {
                ::std::option::Option::Some(signature::Signature::Ed(v)) => v,
                _ => panic!(),
            }
        } else {
            Ed25519Signature::new()
        }
    }

    // .MultiEd25519Signature multi_ed = 3;

    pub fn multi_ed(&self) -> &MultiEd25519Signature {
        match self.signature {
            ::std::option::Option::Some(signature::Signature::MultiEd(ref v)) => v,
            _ => <MultiEd25519Signature as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_multi_ed(&mut self) {
        self.signature = ::std::option::Option::None;
    }

    pub fn has_multi_ed(&self) -> bool {
        match self.signature {
            ::std::option::Option::Some(signature::Signature::MultiEd(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_multi_ed(&mut self, v: MultiEd25519Signature) {
        self.signature = ::std::option::Option::Some(signature::Signature::MultiEd(v))
    }

    // Mutable pointer to the field.
    pub fn mut_multi_ed(&mut self) -> &mut MultiEd25519Signature {
        if let ::std::option::Option::Some(signature::Signature::MultiEd(_)) = self.signature {
        } else {
            self.signature = ::std::option::Option::Some(signature::Signature::MultiEd(MultiEd25519Signature::new()));
        }
        match self.signature {
            ::std::option::Option::Some(signature::Signature::MultiEd(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_multi_ed(&mut self) -> MultiEd25519Signature {
        if self.has_multi_ed() {
            match self.signature.take() {
                ::std::option::Option::Some(signature::Signature::MultiEd(v)) => v,
                _ => panic!(),
            }
        } else {
            MultiEd25519Signature::new()
        }
    }

    // .MultiAgentSignature multi_agent = 4;

    pub fn multi_agent(&self) -> &MultiAgentSignature {
        match self.signature {
            ::std::option::Option::Some(signature::Signature::MultiAgent(ref v)) => v,
            _ => <MultiAgentSignature as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_multi_agent(&mut self) {
        self.signature = ::std::option::Option::None;
    }

    pub fn has_multi_agent(&self) -> bool {
        match self.signature {
            ::std::option::Option::Some(signature::Signature::MultiAgent(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_multi_agent(&mut self, v: MultiAgentSignature) {
        self.signature = ::std::option::Option::Some(signature::Signature::MultiAgent(v))
    }

    // Mutable pointer to the field.
    pub fn mut_multi_agent(&mut self) -> &mut MultiAgentSignature {
        if let ::std::option::Option::Some(signature::Signature::MultiAgent(_)) = self.signature {
        } else {
            self.signature = ::std::option::Option::Some(signature::Signature::MultiAgent(MultiAgentSignature::new()));
        }
        match self.signature {
            ::std::option::Option::Some(signature::Signature::MultiAgent(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_multi_agent(&mut self) -> MultiAgentSignature {
        if self.has_multi_agent() {
            match self.signature.take() {
                ::std::option::Option::Some(signature::Signature::MultiAgent(v)) => v,
                _ => panic!(),
            }
        } else {
            MultiAgentSignature::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &Signature| { &m.type_ },
            |m: &mut Signature| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Ed25519Signature>(
            "ed",
            Signature::has_ed,
            Signature::ed,
            Signature::mut_ed,
            Signature::set_ed,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, MultiEd25519Signature>(
            "multi_ed",
            Signature::has_multi_ed,
            Signature::multi_ed,
            Signature::mut_multi_ed,
            Signature::set_multi_ed,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, MultiAgentSignature>(
            "multi_agent",
            Signature::has_multi_agent,
            Signature::multi_agent,
            Signature::mut_multi_agent,
            Signature::set_multi_agent,
        ));
        oneofs.push(signature::Signature::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Signature>(
            "Signature",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Signature {
    const NAME: &'static str = "Signature";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.signature = ::std::option::Option::Some(signature::Signature::Ed(is.read_message()?));
                },
                26 => {
                    self.signature = ::std::option::Option::Some(signature::Signature::MultiEd(is.read_message()?));
                },
                34 => {
                    self.signature = ::std::option::Option::Some(signature::Signature::MultiAgent(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.type_ != ::protobuf::EnumOrUnknown::new(signature::SignatureType::ED) {
            my_size += ::protobuf::rt::int32_size(1, self.type_.value());
        }
        if let ::std::option::Option::Some(ref v) = self.signature {
            match v {
                &signature::Signature::Ed(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &signature::Signature::MultiEd(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &signature::Signature::MultiAgent(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.type_ != ::protobuf::EnumOrUnknown::new(signature::SignatureType::ED) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        if let ::std::option::Option::Some(ref v) = self.signature {
            match v {
                &signature::Signature::Ed(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &signature::Signature::MultiEd(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &signature::Signature::MultiAgent(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Signature {
        Signature::new()
    }

    fn clear(&mut self) {
        self.type_ = ::protobuf::EnumOrUnknown::new(signature::SignatureType::ED);
        self.signature = ::std::option::Option::None;
        self.signature = ::std::option::Option::None;
        self.signature = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Signature {
        static instance: Signature = Signature {
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            signature: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Signature {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Signature").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Signature {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Signature {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Signature`
pub mod signature {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:Signature.signature)
    pub enum Signature {
        // @@protoc_insertion_point(oneof_field:Signature.ed)
        Ed(super::Ed25519Signature),
        // @@protoc_insertion_point(oneof_field:Signature.multi_ed)
        MultiEd(super::MultiEd25519Signature),
        // @@protoc_insertion_point(oneof_field:Signature.multi_agent)
        MultiAgent(super::MultiAgentSignature),
    }

    impl ::protobuf::Oneof for Signature {
    }

    impl ::protobuf::OneofFull for Signature {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::Signature as ::protobuf::MessageFull>::descriptor().oneof_by_name("signature").unwrap()).clone()
        }
    }

    impl Signature {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Signature>("signature")
        }
    }
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:Signature.SignatureType)
    pub enum SignatureType {
        // @@protoc_insertion_point(enum_value:Signature.SignatureType.ED)
        ED = 0,
        // @@protoc_insertion_point(enum_value:Signature.SignatureType.MULTI_ED)
        MULTI_ED = 1,
        // @@protoc_insertion_point(enum_value:Signature.SignatureType.MULTI_AGENT)
        MULTI_AGENT = 2,
    }

    impl ::protobuf::Enum for SignatureType {
        const NAME: &'static str = "SignatureType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<SignatureType> {
            match value {
                0 => ::std::option::Option::Some(SignatureType::ED),
                1 => ::std::option::Option::Some(SignatureType::MULTI_ED),
                2 => ::std::option::Option::Some(SignatureType::MULTI_AGENT),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [SignatureType] = &[
            SignatureType::ED,
            SignatureType::MULTI_ED,
            SignatureType::MULTI_AGENT,
        ];
    }

    impl ::protobuf::EnumFull for SignatureType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("Signature.SignatureType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for SignatureType {
        fn default() -> Self {
            SignatureType::ED
        }
    }

    impl SignatureType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<SignatureType>("Signature.SignatureType")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:Ed25519Signature)
pub struct Ed25519Signature {
    // message fields
    // @@protoc_insertion_point(field:Ed25519Signature.public_key)
    pub public_key: ::std::string::String,
    // @@protoc_insertion_point(field:Ed25519Signature.signature)
    pub signature: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:Ed25519Signature.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Ed25519Signature {
    fn default() -> &'a Ed25519Signature {
        <Ed25519Signature as ::protobuf::Message>::default_instance()
    }
}

impl Ed25519Signature {
    pub fn new() -> Ed25519Signature {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "public_key",
            |m: &Ed25519Signature| { &m.public_key },
            |m: &mut Ed25519Signature| { &mut m.public_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "signature",
            |m: &Ed25519Signature| { &m.signature },
            |m: &mut Ed25519Signature| { &mut m.signature },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Ed25519Signature>(
            "Ed25519Signature",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Ed25519Signature {
    const NAME: &'static str = "Ed25519Signature";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.public_key = is.read_string()?;
                },
                18 => {
                    self.signature = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.public_key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.public_key);
        }
        if !self.signature.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.signature);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.public_key.is_empty() {
            os.write_string(1, &self.public_key)?;
        }
        if !self.signature.is_empty() {
            os.write_string(2, &self.signature)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Ed25519Signature {
        Ed25519Signature::new()
    }

    fn clear(&mut self) {
        self.public_key.clear();
        self.signature.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Ed25519Signature {
        static instance: Ed25519Signature = Ed25519Signature {
            public_key: ::std::string::String::new(),
            signature: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Ed25519Signature {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Ed25519Signature").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Ed25519Signature {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Ed25519Signature {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:MultiEd25519Signature)
pub struct MultiEd25519Signature {
    // message fields
    // @@protoc_insertion_point(field:MultiEd25519Signature.public_keys)
    pub public_keys: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:MultiEd25519Signature.signatures)
    pub signatures: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:MultiEd25519Signature.threshold)
    pub threshold: u32,
    // @@protoc_insertion_point(field:MultiEd25519Signature.bitmap)
    pub bitmap: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:MultiEd25519Signature.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiEd25519Signature {
    fn default() -> &'a MultiEd25519Signature {
        <MultiEd25519Signature as ::protobuf::Message>::default_instance()
    }
}

impl MultiEd25519Signature {
    pub fn new() -> MultiEd25519Signature {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "public_keys",
            |m: &MultiEd25519Signature| { &m.public_keys },
            |m: &mut MultiEd25519Signature| { &mut m.public_keys },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "signatures",
            |m: &MultiEd25519Signature| { &m.signatures },
            |m: &mut MultiEd25519Signature| { &mut m.signatures },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "threshold",
            |m: &MultiEd25519Signature| { &m.threshold },
            |m: &mut MultiEd25519Signature| { &mut m.threshold },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "bitmap",
            |m: &MultiEd25519Signature| { &m.bitmap },
            |m: &mut MultiEd25519Signature| { &mut m.bitmap },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiEd25519Signature>(
            "MultiEd25519Signature",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiEd25519Signature {
    const NAME: &'static str = "MultiEd25519Signature";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.public_keys.push(is.read_string()?);
                },
                18 => {
                    self.signatures.push(is.read_string()?);
                },
                24 => {
                    self.threshold = is.read_uint32()?;
                },
                34 => {
                    self.bitmap = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.public_keys {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.signatures {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if self.threshold != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.threshold);
        }
        if !self.bitmap.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.bitmap);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.public_keys {
            os.write_string(1, &v)?;
        };
        for v in &self.signatures {
            os.write_string(2, &v)?;
        };
        if self.threshold != 0 {
            os.write_uint32(3, self.threshold)?;
        }
        if !self.bitmap.is_empty() {
            os.write_string(4, &self.bitmap)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiEd25519Signature {
        MultiEd25519Signature::new()
    }

    fn clear(&mut self) {
        self.public_keys.clear();
        self.signatures.clear();
        self.threshold = 0;
        self.bitmap.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiEd25519Signature {
        static instance: MultiEd25519Signature = MultiEd25519Signature {
            public_keys: ::std::vec::Vec::new(),
            signatures: ::std::vec::Vec::new(),
            threshold: 0,
            bitmap: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiEd25519Signature {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiEd25519Signature").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiEd25519Signature {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiEd25519Signature {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:MultiAgentSignature)
pub struct MultiAgentSignature {
    // message fields
    // @@protoc_insertion_point(field:MultiAgentSignature.sender)
    pub sender: ::protobuf::MessageField<AccountSignature>,
    // @@protoc_insertion_point(field:MultiAgentSignature.secondary_signer_addresses)
    pub secondary_signer_addresses: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:MultiAgentSignature.secondary_signers)
    pub secondary_signers: ::std::vec::Vec<AccountSignature>,
    // special fields
    // @@protoc_insertion_point(special_field:MultiAgentSignature.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiAgentSignature {
    fn default() -> &'a MultiAgentSignature {
        <MultiAgentSignature as ::protobuf::Message>::default_instance()
    }
}

impl MultiAgentSignature {
    pub fn new() -> MultiAgentSignature {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AccountSignature>(
            "sender",
            |m: &MultiAgentSignature| { &m.sender },
            |m: &mut MultiAgentSignature| { &mut m.sender },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "secondary_signer_addresses",
            |m: &MultiAgentSignature| { &m.secondary_signer_addresses },
            |m: &mut MultiAgentSignature| { &mut m.secondary_signer_addresses },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "secondary_signers",
            |m: &MultiAgentSignature| { &m.secondary_signers },
            |m: &mut MultiAgentSignature| { &mut m.secondary_signers },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiAgentSignature>(
            "MultiAgentSignature",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiAgentSignature {
    const NAME: &'static str = "MultiAgentSignature";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.sender)?;
                },
                18 => {
                    self.secondary_signer_addresses.push(is.read_string()?);
                },
                26 => {
                    self.secondary_signers.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.sender.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.secondary_signer_addresses {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.secondary_signers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.sender.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.secondary_signer_addresses {
            os.write_string(2, &v)?;
        };
        for v in &self.secondary_signers {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiAgentSignature {
        MultiAgentSignature::new()
    }

    fn clear(&mut self) {
        self.sender.clear();
        self.secondary_signer_addresses.clear();
        self.secondary_signers.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiAgentSignature {
        static instance: MultiAgentSignature = MultiAgentSignature {
            sender: ::protobuf::MessageField::none(),
            secondary_signer_addresses: ::std::vec::Vec::new(),
            secondary_signers: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiAgentSignature {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiAgentSignature").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiAgentSignature {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiAgentSignature {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:AccountSignature)
pub struct AccountSignature {
    // message fields
    // @@protoc_insertion_point(field:AccountSignature.type)
    pub type_: ::protobuf::EnumOrUnknown<account_signature::AccountSignatureType>,
    // message oneof groups
    pub signature: ::std::option::Option<account_signature::Signature>,
    // special fields
    // @@protoc_insertion_point(special_field:AccountSignature.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AccountSignature {
    fn default() -> &'a AccountSignature {
        <AccountSignature as ::protobuf::Message>::default_instance()
    }
}

impl AccountSignature {
    pub fn new() -> AccountSignature {
        ::std::default::Default::default()
    }

    // .Ed25519Signature ed = 2;

    pub fn ed(&self) -> &Ed25519Signature {
        match self.signature {
            ::std::option::Option::Some(account_signature::Signature::Ed(ref v)) => v,
            _ => <Ed25519Signature as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_ed(&mut self) {
        self.signature = ::std::option::Option::None;
    }

    pub fn has_ed(&self) -> bool {
        match self.signature {
            ::std::option::Option::Some(account_signature::Signature::Ed(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ed(&mut self, v: Ed25519Signature) {
        self.signature = ::std::option::Option::Some(account_signature::Signature::Ed(v))
    }

    // Mutable pointer to the field.
    pub fn mut_ed(&mut self) -> &mut Ed25519Signature {
        if let ::std::option::Option::Some(account_signature::Signature::Ed(_)) = self.signature {
        } else {
            self.signature = ::std::option::Option::Some(account_signature::Signature::Ed(Ed25519Signature::new()));
        }
        match self.signature {
            ::std::option::Option::Some(account_signature::Signature::Ed(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_ed(&mut self) -> Ed25519Signature {
        if self.has_ed() {
            match self.signature.take() {
                ::std::option::Option::Some(account_signature::Signature::Ed(v)) => v,
                _ => panic!(),
            }
        } else {
            Ed25519Signature::new()
        }
    }

    // .MultiEd25519Signature multi_ed = 3;

    pub fn multi_ed(&self) -> &MultiEd25519Signature {
        match self.signature {
            ::std::option::Option::Some(account_signature::Signature::MultiEd(ref v)) => v,
            _ => <MultiEd25519Signature as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_multi_ed(&mut self) {
        self.signature = ::std::option::Option::None;
    }

    pub fn has_multi_ed(&self) -> bool {
        match self.signature {
            ::std::option::Option::Some(account_signature::Signature::MultiEd(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_multi_ed(&mut self, v: MultiEd25519Signature) {
        self.signature = ::std::option::Option::Some(account_signature::Signature::MultiEd(v))
    }

    // Mutable pointer to the field.
    pub fn mut_multi_ed(&mut self) -> &mut MultiEd25519Signature {
        if let ::std::option::Option::Some(account_signature::Signature::MultiEd(_)) = self.signature {
        } else {
            self.signature = ::std::option::Option::Some(account_signature::Signature::MultiEd(MultiEd25519Signature::new()));
        }
        match self.signature {
            ::std::option::Option::Some(account_signature::Signature::MultiEd(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_multi_ed(&mut self) -> MultiEd25519Signature {
        if self.has_multi_ed() {
            match self.signature.take() {
                ::std::option::Option::Some(account_signature::Signature::MultiEd(v)) => v,
                _ => panic!(),
            }
        } else {
            MultiEd25519Signature::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &AccountSignature| { &m.type_ },
            |m: &mut AccountSignature| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Ed25519Signature>(
            "ed",
            AccountSignature::has_ed,
            AccountSignature::ed,
            AccountSignature::mut_ed,
            AccountSignature::set_ed,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, MultiEd25519Signature>(
            "multi_ed",
            AccountSignature::has_multi_ed,
            AccountSignature::multi_ed,
            AccountSignature::mut_multi_ed,
            AccountSignature::set_multi_ed,
        ));
        oneofs.push(account_signature::Signature::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AccountSignature>(
            "AccountSignature",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AccountSignature {
    const NAME: &'static str = "AccountSignature";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.signature = ::std::option::Option::Some(account_signature::Signature::Ed(is.read_message()?));
                },
                26 => {
                    self.signature = ::std::option::Option::Some(account_signature::Signature::MultiEd(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.type_ != ::protobuf::EnumOrUnknown::new(account_signature::AccountSignatureType::ED) {
            my_size += ::protobuf::rt::int32_size(1, self.type_.value());
        }
        if let ::std::option::Option::Some(ref v) = self.signature {
            match v {
                &account_signature::Signature::Ed(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &account_signature::Signature::MultiEd(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.type_ != ::protobuf::EnumOrUnknown::new(account_signature::AccountSignatureType::ED) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        if let ::std::option::Option::Some(ref v) = self.signature {
            match v {
                &account_signature::Signature::Ed(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &account_signature::Signature::MultiEd(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AccountSignature {
        AccountSignature::new()
    }

    fn clear(&mut self) {
        self.type_ = ::protobuf::EnumOrUnknown::new(account_signature::AccountSignatureType::ED);
        self.signature = ::std::option::Option::None;
        self.signature = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AccountSignature {
        static instance: AccountSignature = AccountSignature {
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            signature: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AccountSignature {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AccountSignature").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AccountSignature {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AccountSignature {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `AccountSignature`
pub mod account_signature {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:AccountSignature.signature)
    pub enum Signature {
        // @@protoc_insertion_point(oneof_field:AccountSignature.ed)
        Ed(super::Ed25519Signature),
        // @@protoc_insertion_point(oneof_field:AccountSignature.multi_ed)
        MultiEd(super::MultiEd25519Signature),
    }

    impl ::protobuf::Oneof for Signature {
    }

    impl ::protobuf::OneofFull for Signature {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::AccountSignature as ::protobuf::MessageFull>::descriptor().oneof_by_name("signature").unwrap()).clone()
        }
    }

    impl Signature {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Signature>("signature")
        }
    }
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:AccountSignature.AccountSignatureType)
    pub enum AccountSignatureType {
        // @@protoc_insertion_point(enum_value:AccountSignature.AccountSignatureType.ED)
        ED = 0,
        // @@protoc_insertion_point(enum_value:AccountSignature.AccountSignatureType.MULTI_ED)
        MULTI_ED = 1,
    }

    impl ::protobuf::Enum for AccountSignatureType {
        const NAME: &'static str = "AccountSignatureType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<AccountSignatureType> {
            match value {
                0 => ::std::option::Option::Some(AccountSignatureType::ED),
                1 => ::std::option::Option::Some(AccountSignatureType::MULTI_ED),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [AccountSignatureType] = &[
            AccountSignatureType::ED,
            AccountSignatureType::MULTI_ED,
        ];
    }

    impl ::protobuf::EnumFull for AccountSignatureType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("AccountSignature.AccountSignatureType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for AccountSignatureType {
        fn default() -> Self {
            AccountSignatureType::ED
        }
    }

    impl AccountSignatureType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<AccountSignatureType>("AccountSignature.AccountSignatureType")
        }
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1asrc/protos/extractor.proto\"\xb9\x04\n\x0bTransaction\x12\x1c\n\tt\
    imestamp\x18\x01\x20\x01(\x04R\ttimestamp\x12\x18\n\x07version\x18\x02\
    \x20\x01(\x04R\x07version\x12$\n\x04info\x18\x03\x20\x01(\x0b2\x10.Trans\
    actionInfoR\x04info\x12\x14\n\x05epoch\x18\x04\x20\x01(\x04R\x05epoch\
    \x12!\n\x0cblock_height\x18\x05\x20\x01(\x04R\x0bblockHeight\x120\n\x04t\
    ype\x18\x06\x20\x01(\x0e2\x1c.Transaction.TransactionTypeR\x04type\x12I\
    \n\x12block_metadata_txn\x18\x07\x20\x01(\x0b2\x19.BlockMetadataTransact\
    ionH\0R\x10blockMetadataTxn\x126\n\x0bgenesis_txn\x18\x08\x20\x01(\x0b2\
    \x13.GenesisTransactionH\0R\ngenesisTxn\x12O\n\x14state_checkpoint_txn\
    \x18\t\x20\x01(\x0b2\x1b.StateCheckpointTransactionH\0R\x12stateCheckpoi\
    ntTxn\x12-\n\x08user_txn\x18\n\x20\x01(\x0b2\x10.UserTransactionH\0R\x07\
    userTxn\"R\n\x0fTransactionType\x12\x0b\n\x07GENESIS\x10\0\x12\x12\n\x0e\
    BLOCK_METADATA\x10\x01\x12\x14\n\x10STATE_CHECKPOINT\x10\x02\x12\x08\n\
    \x04USER\x10\x03B\n\n\x08txn_data\"\xe6\x01\n\x18BlockMetadataTransactio\
    n\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\x14\n\x05round\x18\x02\
    \x20\x01(\x04R\x05round\x12\x1e\n\x06events\x18\x03\x20\x03(\x0b2\x06.Ev\
    entR\x06events\x120\n\x14previous_block_votes\x18\x04\x20\x03(\x08R\x12p\
    reviousBlockVotes\x12\x1a\n\x08proposer\x18\x05\x20\x01(\tR\x08proposer\
    \x126\n\x17failed_proposer_indices\x18\x06\x20\x03(\rR\x15failedProposer\
    Indices\"Y\n\x12GenesisTransaction\x12#\n\x07payload\x18\x01\x20\x01(\
    \x0b2\t.WriteSetR\x07payload\x12\x1e\n\x06events\x18\x02\x20\x03(\x0b2\
    \x06.EventR\x06events\"\x1c\n\x1aStateCheckpointTransaction\"d\n\x0fUser\
    Transaction\x121\n\x07request\x18\x01\x20\x01(\x0b2\x17.UserTransactionR\
    equestR\x07request\x12\x1e\n\x06events\x18\x02\x20\x03(\x0b2\x06.EventR\
    \x06events\"u\n\x05Event\x12\x1b\n\x03key\x18\x01\x20\x01(\x0b2\t.EventK\
    eyR\x03key\x12'\n\x0fsequence_number\x18\x02\x20\x01(\x04R\x0esequenceNu\
    mber\x12\x12\n\x04type\x18\x03\x20\x01(\tR\x04type\x12\x12\n\x04data\x18\
    \x04\x20\x01(\tR\x04data\"\xa6\x02\n\x0fTransactionInfo\x12\x12\n\x04has\
    h\x18\x01\x20\x01(\tR\x04hash\x12&\n\x0fstate_root_hash\x18\x02\x20\x01(\
    \tR\rstateRootHash\x12&\n\x0fevent_root_hash\x18\x03\x20\x01(\tR\reventR\
    ootHash\x12\x19\n\x08gas_used\x18\x04\x20\x01(\x04R\x07gasUsed\x12\x18\n\
    \x07success\x18\x05\x20\x01(\x08R\x07success\x12\x1b\n\tvm_status\x18\
    \x06\x20\x01(\tR\x08vmStatus\x122\n\x15accumulator_root_hash\x18\x07\x20\
    \x01(\tR\x13accumulatorRootHash\x12)\n\x07changes\x18\x08\x20\x03(\x0b2\
    \x0f.WriteSetChangeR\x07changes\"\\\n\x08EventKey\x12'\n\x0fcreation_num\
    ber\x18\x01\x20\x01(\x04R\x0ecreationNumber\x12'\n\x0faccount_address\
    \x18\x02\x20\x01(\tR\x0eaccountAddress\"\xba\x02\n\x16UserTransactionReq\
    uest\x12\x16\n\x06sender\x18\x01\x20\x01(\tR\x06sender\x12'\n\x0fsequenc\
    e_number\x18\x02\x20\x01(\x04R\x0esequenceNumber\x12$\n\x0emax_gas_amoun\
    t\x18\x03\x20\x01(\x04R\x0cmaxGasAmount\x12$\n\x0egas_unit_price\x18\x04\
    \x20\x01(\x04R\x0cgasUnitPrice\x12:\n\x19expiration_timestamp_secs\x18\
    \x05\x20\x01(\x04R\x17expirationTimestampSecs\x12-\n\x07payload\x18\x06\
    \x20\x01(\x0b2\x13.TransactionPayloadR\x07payload\x12(\n\tsignature\x18\
    \x07\x20\x01(\x0b2\n.SignatureR\tsignature\"\x8b\x02\n\x08WriteSet\x12<\
    \n\x0ewrite_set_type\x18\x01\x20\x01(\x0e2\x16.WriteSet.WriteSetTypeR\
    \x0cwriteSetType\x12;\n\x10script_write_set\x18\x02\x20\x01(\x0b2\x0f.Sc\
    riptWriteSetH\0R\x0escriptWriteSet\x12;\n\x10direct_write_set\x18\x03\
    \x20\x01(\x0b2\x0f.DirectWriteSetH\0R\x0edirectWriteSet\":\n\x0cWriteSet\
    Type\x12\x14\n\x10SCRIPT_WRITE_SET\x10\0\x12\x14\n\x10DIRECT_WRITE_SET\
    \x10\x01B\x0b\n\twrite_set\"W\n\x0eScriptWriteSet\x12\x1d\n\nexecute_as\
    \x18\x01\x20\x01(\tR\texecuteAs\x12&\n\x06script\x18\x02\x20\x01(\x0b2\
    \x0e.ScriptPayloadR\x06script\"k\n\x0eDirectWriteSet\x129\n\x10write_set\
    _change\x18\x01\x20\x03(\x0b2\x0f.WriteSetChangeR\x0ewriteSetChange\x12\
    \x1e\n\x06events\x18\x02\x20\x03(\x0b2\x06.EventR\x06events\"\xbf\x04\n\
    \x0eWriteSetChange\x126\n\x04type\x18\x01\x20\x01(\x0e2\".WriteSetChange\
    .WriteSetChangeTypeR\x04type\x124\n\rdelete_module\x18\x02\x20\x01(\x0b2\
    \r.DeleteModuleH\0R\x0cdeleteModule\x12:\n\x0fdelete_resource\x18\x03\
    \x20\x01(\x0b2\x0f.DeleteResourceH\0R\x0edeleteResource\x12>\n\x11delete\
    _table_item\x18\x04\x20\x01(\x0b2\x10.DeleteTableItemH\0R\x0fdeleteTable\
    Item\x121\n\x0cwrite_module\x18\x05\x20\x01(\x0b2\x0c.WriteModuleH\0R\
    \x0bwriteModule\x127\n\x0ewrite_resource\x18\x06\x20\x01(\x0b2\x0e.Write\
    ResourceH\0R\rwriteResource\x12;\n\x10write_table_item\x18\x07\x20\x01(\
    \x0b2\x0f.WriteTableItemH\0R\x0ewriteTableItem\"\x8f\x01\n\x12WriteSetCh\
    angeType\x12\x11\n\rDELETE_MODULE\x10\0\x12\x13\n\x0fDELETE_RESOURCE\x10\
    \x01\x12\x15\n\x11DELETE_TABLE_ITEM\x10\x02\x12\x10\n\x0cWRITE_MODULE\
    \x10\x03\x12\x12\n\x0eWRITE_RESOURCE\x10\x04\x12\x14\n\x10WRITE_TABLE_IT\
    EM\x10\x05B\x08\n\x06change\"u\n\x0cDeleteModule\x12\x18\n\x07address\
    \x18\x01\x20\x01(\tR\x07address\x12$\n\x0estate_key_hash\x18\x02\x20\x01\
    (\tR\x0cstateKeyHash\x12%\n\x06module\x18\x03\x20\x01(\x0b2\r.MoveModule\
    IdR\x06module\"|\n\x0eDeleteResource\x12\x18\n\x07address\x18\x01\x20\
    \x01(\tR\x07address\x12$\n\x0estate_key_hash\x18\x02\x20\x01(\tR\x0cstat\
    eKeyHash\x12*\n\x08resource\x18\x03\x20\x01(\x0b2\x0e.MoveStructTagR\x08\
    resource\"a\n\x0fDeleteTableItem\x12$\n\x0estate_key_hash\x18\x01\x20\
    \x01(\tR\x0cstateKeyHash\x12\x16\n\x06handle\x18\x02\x20\x01(\tR\x06hand\
    le\x12\x10\n\x03key\x18\x03\x20\x01(\tR\x03key\"a\n\x0bWriteModule\x12\
    \x18\n\x07address\x18\x01\x20\x01(\tR\x07address\x12$\n\x0estate_key_has\
    h\x18\x02\x20\x01(\tR\x0cstateKeyHash\x12\x12\n\x04data\x18\x03\x20\x01(\
    \tR\x04data\"r\n\rWriteResource\x12\x18\n\x07address\x18\x01\x20\x01(\tR\
    \x07address\x12$\n\x0estate_key_hash\x18\x02\x20\x01(\tR\x0cstateKeyHash\
    \x12!\n\x04data\x18\x03\x20\x01(\x0b2\r.MoveResourceR\x04data\"v\n\x0eWr\
    iteTableItem\x12$\n\x0estate_key_hash\x18\x01\x20\x01(\tR\x0cstateKeyHas\
    h\x12\x16\n\x06handle\x18\x02\x20\x01(\tR\x06handle\x12\x10\n\x03key\x18\
    \x03\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x04\x20\x01(\tR\x05value\
    \"\xdd\x03\n\x12TransactionPayload\x123\n\x04type\x18\x01\x20\x01(\x0e2\
    \x1f.TransactionPayload.PayloadTypeR\x04type\x12P\n\x17script_function_p\
    ayload\x18\x02\x20\x01(\x0b2\x16.ScriptFunctionPayloadH\0R\x15scriptFunc\
    tionPayload\x127\n\x0escript_payload\x18\x03\x20\x01(\x0b2\x0e.ScriptPay\
    loadH\0R\rscriptPayload\x12J\n\x15module_bundle_payload\x18\x04\x20\x01(\
    \x0b2\x14.ModuleBundlePayloadH\0R\x13moduleBundlePayload\x12>\n\x11write\
    _set_payload\x18\x05\x20\x01(\x0b2\x10.WriteSetPayloadH\0R\x0fwriteSetPa\
    yload\"p\n\x0bPayloadType\x12\x1b\n\x17SCRIPT_FUNCTION_PAYLOAD\x10\0\x12\
    \x12\n\x0eSCRIPT_PAYLOAD\x10\x01\x12\x19\n\x15MODULE_BUNDLE_PAYLOAD\x10\
    \x02\x12\x15\n\x11WRITE_SET_PAYLOAD\x10\x03B\t\n\x07payload\"\x8b\x01\n\
    \x15ScriptFunctionPayload\x12-\n\x08function\x18\x01\x20\x01(\x0b2\x11.S\
    criptFunctionIdR\x08function\x12%\n\x0etype_arguments\x18\x02\x20\x03(\t\
    R\rtypeArguments\x12\x1c\n\targuments\x18\x03\x20\x03(\tR\targuments\"h\
    \n\rScriptPayload\x12\x12\n\x04code\x18\x01\x20\x01(\tR\x04code\x12%\n\
    \x0etype_arguments\x18\x02\x20\x03(\tR\rtypeArguments\x12\x1c\n\targumen\
    ts\x18\x03\x20\x03(\tR\targuments\"/\n\x13ModuleBundlePayload\x12\x18\n\
    \x07modules\x18\x01\x20\x03(\tR\x07modules\"9\n\x0fWriteSetPayload\x12&\
    \n\twrite_set\x18\x01\x20\x01(\x0b2\t.WriteSetR\x08writeSet\"M\n\x10Scri\
    ptFunctionId\x12%\n\x06module\x18\x01\x20\x01(\x0b2\r.MoveModuleIdR\x06m\
    odule\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\"F\n\x0cMoveResource\
    \x12\"\n\x04type\x18\x01\x20\x01(\x0b2\x0e.MoveStructTagR\x04type\x12\
    \x12\n\x04data\x18\x02\x20\x01(\tR\x04data\"<\n\x0cMoveModuleId\x12\x18\
    \n\x07address\x18\x01\x20\x01(\tR\x07address\x12\x12\n\x04name\x18\x02\
    \x20\x01(\tR\x04name\"\x85\x01\n\rMoveStructTag\x12\x18\n\x07address\x18\
    \x01\x20\x01(\tR\x07address\x12\x16\n\x06module\x18\x02\x20\x01(\tR\x06m\
    odule\x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04name\x12.\n\x13generic_ty\
    pe_params\x18\x04\x20\x03(\tR\x11genericTypeParams\"\x91\x02\n\tSignatur\
    e\x12,\n\x04type\x18\x01\x20\x01(\x0e2\x18.Signature.SignatureTypeR\x04t\
    ype\x12#\n\x02ed\x18\x02\x20\x01(\x0b2\x11.Ed25519SignatureH\0R\x02ed\
    \x123\n\x08multi_ed\x18\x03\x20\x01(\x0b2\x16.MultiEd25519SignatureH\0R\
    \x07multiEd\x127\n\x0bmulti_agent\x18\x04\x20\x01(\x0b2\x14.MultiAgentSi\
    gnatureH\0R\nmultiAgent\"6\n\rSignatureType\x12\x06\n\x02ED\x10\0\x12\
    \x0c\n\x08MULTI_ED\x10\x01\x12\x0f\n\x0bMULTI_AGENT\x10\x02B\x0b\n\tsign\
    ature\"O\n\x10Ed25519Signature\x12\x1d\n\npublic_key\x18\x01\x20\x01(\tR\
    \tpublicKey\x12\x1c\n\tsignature\x18\x02\x20\x01(\tR\tsignature\"\x8e\
    \x01\n\x15MultiEd25519Signature\x12\x1f\n\x0bpublic_keys\x18\x01\x20\x03\
    (\tR\npublicKeys\x12\x1e\n\nsignatures\x18\x02\x20\x03(\tR\nsignatures\
    \x12\x1c\n\tthreshold\x18\x03\x20\x01(\rR\tthreshold\x12\x16\n\x06bitmap\
    \x18\x04\x20\x01(\tR\x06bitmap\"\xbe\x01\n\x13MultiAgentSignature\x12)\n\
    \x06sender\x18\x01\x20\x01(\x0b2\x11.AccountSignatureR\x06sender\x12<\n\
    \x1asecondary_signer_addresses\x18\x02\x20\x03(\tR\x18secondarySignerAdd\
    resses\x12>\n\x11secondary_signers\x18\x03\x20\x03(\x0b2\x11.AccountSign\
    atureR\x10secondarySigners\"\xe3\x01\n\x10AccountSignature\x12:\n\x04typ\
    e\x18\x01\x20\x01(\x0e2&.AccountSignature.AccountSignatureTypeR\x04type\
    \x12#\n\x02ed\x18\x02\x20\x01(\x0b2\x11.Ed25519SignatureH\0R\x02ed\x123\
    \n\x08multi_ed\x18\x03\x20\x01(\x0b2\x16.MultiEd25519SignatureH\0R\x07mu\
    ltiEd\",\n\x14AccountSignatureType\x12\x06\n\x02ED\x10\0\x12\x0c\n\x08MU\
    LTI_ED\x10\x01B\x0b\n\tsignatureJ\xb2F\n\x07\x12\x05\x03\0\x92\x02\x01\n\
    D\n\x01\x0c\x12\x03\x03\0\x122:\x20Copyright\x20(c)\x20Aptos\n\x20SPDX-L\
    icense-Identifier:\x20Apache-2.0\n\n\n\n\x02\x04\0\x12\x04\x05\0\x1c\x01\
    \n\n\n\x03\x04\0\x01\x12\x03\x05\x08\x13\n\x0b\n\x04\x04\0\x02\0\x12\x03\
    \x06\x02\x17\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03\x06\x02\x08\n\x0c\n\x05\
    \x04\0\x02\0\x01\x12\x03\x06\t\x12\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03\
    \x06\x15\x16\n\x0b\n\x04\x04\0\x02\x01\x12\x03\x07\x02\x15\n\x0c\n\x05\
    \x04\0\x02\x01\x05\x12\x03\x07\x02\x08\n\x0c\n\x05\x04\0\x02\x01\x01\x12\
    \x03\x07\t\x10\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03\x07\x13\x14\n\x0b\n\
    \x04\x04\0\x02\x02\x12\x03\x08\x02\x1b\n\x0c\n\x05\x04\0\x02\x02\x06\x12\
    \x03\x08\x02\x11\n\x0c\n\x05\x04\0\x02\x02\x01\x12\x03\x08\x12\x16\n\x0c\
    \n\x05\x04\0\x02\x02\x03\x12\x03\x08\x19\x1a\n\x0b\n\x04\x04\0\x02\x03\
    \x12\x03\t\x02\x13\n\x0c\n\x05\x04\0\x02\x03\x05\x12\x03\t\x02\x08\n\x0c\
    \n\x05\x04\0\x02\x03\x01\x12\x03\t\t\x0e\n\x0c\n\x05\x04\0\x02\x03\x03\
    \x12\x03\t\x11\x12\n\x0b\n\x04\x04\0\x02\x04\x12\x03\n\x02\x1a\n\x0c\n\
    \x05\x04\0\x02\x04\x05\x12\x03\n\x02\x08\n\x0c\n\x05\x04\0\x02\x04\x01\
    \x12\x03\n\t\x15\n\x0c\n\x05\x04\0\x02\x04\x03\x12\x03\n\x18\x19\n\x0c\n\
    \x04\x04\0\x04\0\x12\x04\x0c\x02\x11\x03\n\x0c\n\x05\x04\0\x04\0\x01\x12\
    \x03\x0c\x07\x16\n\r\n\x06\x04\0\x04\0\x02\0\x12\x03\r\x04\x10\n\x0e\n\
    \x07\x04\0\x04\0\x02\0\x01\x12\x03\r\x04\x0b\n\x0e\n\x07\x04\0\x04\0\x02\
    \0\x02\x12\x03\r\x0e\x0f\n\r\n\x06\x04\0\x04\0\x02\x01\x12\x03\x0e\x04\
    \x17\n\x0e\n\x07\x04\0\x04\0\x02\x01\x01\x12\x03\x0e\x04\x12\n\x0e\n\x07\
    \x04\0\x04\0\x02\x01\x02\x12\x03\x0e\x15\x16\n\r\n\x06\x04\0\x04\0\x02\
    \x02\x12\x03\x0f\x04\x19\n\x0e\n\x07\x04\0\x04\0\x02\x02\x01\x12\x03\x0f\
    \x04\x14\n\x0e\n\x07\x04\0\x04\0\x02\x02\x02\x12\x03\x0f\x17\x18\n\r\n\
    \x06\x04\0\x04\0\x02\x03\x12\x03\x10\x04\r\n\x0e\n\x07\x04\0\x04\0\x02\
    \x03\x01\x12\x03\x10\x04\x08\n\x0e\n\x07\x04\0\x04\0\x02\x03\x02\x12\x03\
    \x10\x0b\x0c\n\x0b\n\x04\x04\0\x02\x05\x12\x03\x13\x02\x1b\n\x0c\n\x05\
    \x04\0\x02\x05\x06\x12\x03\x13\x02\x11\n\x0c\n\x05\x04\0\x02\x05\x01\x12\
    \x03\x13\x12\x16\n\x0c\n\x05\x04\0\x02\x05\x03\x12\x03\x13\x19\x1a\n\x0c\
    \n\x04\x04\0\x08\0\x12\x04\x15\x02\x1a\x03\n\x0c\n\x05\x04\0\x08\0\x01\
    \x12\x03\x15\x08\x10\n\x0b\n\x04\x04\0\x02\x06\x12\x03\x16\x044\n\x0c\n\
    \x05\x04\0\x02\x06\x06\x12\x03\x16\x04\x1c\n\x0c\n\x05\x04\0\x02\x06\x01\
    \x12\x03\x16\x1d/\n\x0c\n\x05\x04\0\x02\x06\x03\x12\x03\x1623\n\x0b\n\
    \x04\x04\0\x02\x07\x12\x03\x17\x04'\n\x0c\n\x05\x04\0\x02\x07\x06\x12\
    \x03\x17\x04\x16\n\x0c\n\x05\x04\0\x02\x07\x01\x12\x03\x17\x17\"\n\x0c\n\
    \x05\x04\0\x02\x07\x03\x12\x03\x17%&\n\x0b\n\x04\x04\0\x02\x08\x12\x03\
    \x18\x048\n\x0c\n\x05\x04\0\x02\x08\x06\x12\x03\x18\x04\x1e\n\x0c\n\x05\
    \x04\0\x02\x08\x01\x12\x03\x18\x1f3\n\x0c\n\x05\x04\0\x02\x08\x03\x12\
    \x03\x1867\n\x0b\n\x04\x04\0\x02\t\x12\x03\x19\x04\"\n\x0c\n\x05\x04\0\
    \x02\t\x06\x12\x03\x19\x04\x13\n\x0c\n\x05\x04\0\x02\t\x01\x12\x03\x19\
    \x14\x1c\n\x0c\n\x05\x04\0\x02\t\x03\x12\x03\x19\x1f!\n\n\n\x02\x04\x01\
    \x12\x04\x1e\0%\x01\n\n\n\x03\x04\x01\x01\x12\x03\x1e\x08\x20\n\x0b\n\
    \x04\x04\x01\x02\0\x12\x03\x1f\x02\x10\n\x0c\n\x05\x04\x01\x02\0\x05\x12\
    \x03\x1f\x02\x08\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03\x1f\t\x0b\n\x0c\n\
    \x05\x04\x01\x02\0\x03\x12\x03\x1f\x0e\x0f\n\x0b\n\x04\x04\x01\x02\x01\
    \x12\x03\x20\x02\x13\n\x0c\n\x05\x04\x01\x02\x01\x05\x12\x03\x20\x02\x08\
    \n\x0c\n\x05\x04\x01\x02\x01\x01\x12\x03\x20\t\x0e\n\x0c\n\x05\x04\x01\
    \x02\x01\x03\x12\x03\x20\x11\x12\n\x0b\n\x04\x04\x01\x02\x02\x12\x03!\
    \x02\x1c\n\x0c\n\x05\x04\x01\x02\x02\x04\x12\x03!\x02\n\n\x0c\n\x05\x04\
    \x01\x02\x02\x06\x12\x03!\x0b\x10\n\x0c\n\x05\x04\x01\x02\x02\x01\x12\
    \x03!\x11\x17\n\x0c\n\x05\x04\x01\x02\x02\x03\x12\x03!\x1a\x1b\n\x0b\n\
    \x04\x04\x01\x02\x03\x12\x03\"\x02)\n\x0c\n\x05\x04\x01\x02\x03\x04\x12\
    \x03\"\x02\n\n\x0c\n\x05\x04\x01\x02\x03\x05\x12\x03\"\x0b\x0f\n\x0c\n\
    \x05\x04\x01\x02\x03\x01\x12\x03\"\x10$\n\x0c\n\x05\x04\x01\x02\x03\x03\
    \x12\x03\"'(\n\x0b\n\x04\x04\x01\x02\x04\x12\x03#\x02\x16\n\x0c\n\x05\
    \x04\x01\x02\x04\x05\x12\x03#\x02\x08\n\x0c\n\x05\x04\x01\x02\x04\x01\
    \x12\x03#\t\x11\n\x0c\n\x05\x04\x01\x02\x04\x03\x12\x03#\x14\x15\n\x0b\n\
    \x04\x04\x01\x02\x05\x12\x03$\x02.\n\x0c\n\x05\x04\x01\x02\x05\x04\x12\
    \x03$\x02\n\n\x0c\n\x05\x04\x01\x02\x05\x05\x12\x03$\x0b\x11\n\x0c\n\x05\
    \x04\x01\x02\x05\x01\x12\x03$\x12)\n\x0c\n\x05\x04\x01\x02\x05\x03\x12\
    \x03$,-\n\n\n\x02\x04\x02\x12\x04'\0*\x01\n\n\n\x03\x04\x02\x01\x12\x03'\
    \x08\x1a\n\x0b\n\x04\x04\x02\x02\0\x12\x03(\x02\x17\n\x0c\n\x05\x04\x02\
    \x02\0\x06\x12\x03(\x02\n\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03(\x0b\x12\
    \n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03(\x15\x16\n\x0b\n\x04\x04\x02\x02\
    \x01\x12\x03)\x02\x1c\n\x0c\n\x05\x04\x02\x02\x01\x04\x12\x03)\x02\n\n\
    \x0c\n\x05\x04\x02\x02\x01\x06\x12\x03)\x0b\x10\n\x0c\n\x05\x04\x02\x02\
    \x01\x01\x12\x03)\x11\x17\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x03)\x1a\
    \x1b\n\n\n\x02\x04\x03\x12\x04,\0-\x01\n\n\n\x03\x04\x03\x01\x12\x03,\
    \x08\"\n\n\n\x02\x04\x04\x12\x04/\02\x01\n\n\n\x03\x04\x04\x01\x12\x03/\
    \x08\x17\n\x0b\n\x04\x04\x04\x02\0\x12\x030\x02%\n\x0c\n\x05\x04\x04\x02\
    \0\x06\x12\x030\x02\x18\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x030\x19\x20\n\
    \x0c\n\x05\x04\x04\x02\0\x03\x12\x030#$\n\x0b\n\x04\x04\x04\x02\x01\x12\
    \x031\x02\x1c\n\x0c\n\x05\x04\x04\x02\x01\x04\x12\x031\x02\n\n\x0c\n\x05\
    \x04\x04\x02\x01\x06\x12\x031\x0b\x10\n\x0c\n\x05\x04\x04\x02\x01\x01\
    \x12\x031\x11\x17\n\x0c\n\x05\x04\x04\x02\x01\x03\x12\x031\x1a\x1b\n\n\n\
    \x02\x04\x05\x12\x044\09\x01\n\n\n\x03\x04\x05\x01\x12\x034\x08\r\n\x0b\
    \n\x04\x04\x05\x02\0\x12\x035\x02\x13\n\x0c\n\x05\x04\x05\x02\0\x06\x12\
    \x035\x02\n\n\x0c\n\x05\x04\x05\x02\0\x01\x12\x035\x0b\x0e\n\x0c\n\x05\
    \x04\x05\x02\0\x03\x12\x035\x11\x12\n\x0b\n\x04\x04\x05\x02\x01\x12\x036\
    \x02\x1d\n\x0c\n\x05\x04\x05\x02\x01\x05\x12\x036\x02\x08\n\x0c\n\x05\
    \x04\x05\x02\x01\x01\x12\x036\t\x18\n\x0c\n\x05\x04\x05\x02\x01\x03\x12\
    \x036\x1b\x1c\n\x0b\n\x04\x04\x05\x02\x02\x12\x037\x02\x12\n\x0c\n\x05\
    \x04\x05\x02\x02\x05\x12\x037\x02\x08\n\x0c\n\x05\x04\x05\x02\x02\x01\
    \x12\x037\t\r\n\x0c\n\x05\x04\x05\x02\x02\x03\x12\x037\x10\x11\n\x0b\n\
    \x04\x04\x05\x02\x03\x12\x038\x02\x12\n\x0c\n\x05\x04\x05\x02\x03\x05\
    \x12\x038\x02\x08\n\x0c\n\x05\x04\x05\x02\x03\x01\x12\x038\t\r\n\x0c\n\
    \x05\x04\x05\x02\x03\x03\x12\x038\x10\x11\n\n\n\x02\x04\x06\x12\x04;\0D\
    \x01\n\n\n\x03\x04\x06\x01\x12\x03;\x08\x17\n\x0b\n\x04\x04\x06\x02\0\
    \x12\x03<\x02\x12\n\x0c\n\x05\x04\x06\x02\0\x05\x12\x03<\x02\x08\n\x0c\n\
    \x05\x04\x06\x02\0\x01\x12\x03<\t\r\n\x0c\n\x05\x04\x06\x02\0\x03\x12\
    \x03<\x10\x11\n\x0b\n\x04\x04\x06\x02\x01\x12\x03=\x02\x1d\n\x0c\n\x05\
    \x04\x06\x02\x01\x05\x12\x03=\x02\x08\n\x0c\n\x05\x04\x06\x02\x01\x01\
    \x12\x03=\t\x18\n\x0c\n\x05\x04\x06\x02\x01\x03\x12\x03=\x1b\x1c\n\x0b\n\
    \x04\x04\x06\x02\x02\x12\x03>\x02\x1d\n\x0c\n\x05\x04\x06\x02\x02\x05\
    \x12\x03>\x02\x08\n\x0c\n\x05\x04\x06\x02\x02\x01\x12\x03>\t\x18\n\x0c\n\
    \x05\x04\x06\x02\x02\x03\x12\x03>\x1b\x1c\n\x0b\n\x04\x04\x06\x02\x03\
    \x12\x03?\x02\x16\n\x0c\n\x05\x04\x06\x02\x03\x05\x12\x03?\x02\x08\n\x0c\
    \n\x05\x04\x06\x02\x03\x01\x12\x03?\t\x11\n\x0c\n\x05\x04\x06\x02\x03\
    \x03\x12\x03?\x14\x15\n\x0b\n\x04\x04\x06\x02\x04\x12\x03@\x02\x13\n\x0c\
    \n\x05\x04\x06\x02\x04\x05\x12\x03@\x02\x06\n\x0c\n\x05\x04\x06\x02\x04\
    \x01\x12\x03@\x07\x0e\n\x0c\n\x05\x04\x06\x02\x04\x03\x12\x03@\x11\x12\n\
    \x0b\n\x04\x04\x06\x02\x05\x12\x03A\x02\x17\n\x0c\n\x05\x04\x06\x02\x05\
    \x05\x12\x03A\x02\x08\n\x0c\n\x05\x04\x06\x02\x05\x01\x12\x03A\t\x12\n\
    \x0c\n\x05\x04\x06\x02\x05\x03\x12\x03A\x15\x16\n\x0b\n\x04\x04\x06\x02\
    \x06\x12\x03B\x02#\n\x0c\n\x05\x04\x06\x02\x06\x05\x12\x03B\x02\x08\n\
    \x0c\n\x05\x04\x06\x02\x06\x01\x12\x03B\t\x1e\n\x0c\n\x05\x04\x06\x02\
    \x06\x03\x12\x03B!\"\n\x0b\n\x04\x04\x06\x02\x07\x12\x03C\x02&\n\x0c\n\
    \x05\x04\x06\x02\x07\x04\x12\x03C\x02\n\n\x0c\n\x05\x04\x06\x02\x07\x06\
    \x12\x03C\x0b\x19\n\x0c\n\x05\x04\x06\x02\x07\x01\x12\x03C\x1a!\n\x0c\n\
    \x05\x04\x06\x02\x07\x03\x12\x03C$%\n\n\n\x02\x04\x07\x12\x04F\0I\x01\n\
    \n\n\x03\x04\x07\x01\x12\x03F\x08\x10\n\x0b\n\x04\x04\x07\x02\0\x12\x03G\
    \x02\x1d\n\x0c\n\x05\x04\x07\x02\0\x05\x12\x03G\x02\x08\n\x0c\n\x05\x04\
    \x07\x02\0\x01\x12\x03G\t\x18\n\x0c\n\x05\x04\x07\x02\0\x03\x12\x03G\x1b\
    \x1c\n\x0b\n\x04\x04\x07\x02\x01\x12\x03H\x02\x1d\n\x0c\n\x05\x04\x07\
    \x02\x01\x05\x12\x03H\x02\x08\n\x0c\n\x05\x04\x07\x02\x01\x01\x12\x03H\t\
    \x18\n\x0c\n\x05\x04\x07\x02\x01\x03\x12\x03H\x1b\x1c\n\n\n\x02\x04\x08\
    \x12\x04K\0S\x01\n\n\n\x03\x04\x08\x01\x12\x03K\x08\x1e\n\x0b\n\x04\x04\
    \x08\x02\0\x12\x03L\x02\x14\n\x0c\n\x05\x04\x08\x02\0\x05\x12\x03L\x02\
    \x08\n\x0c\n\x05\x04\x08\x02\0\x01\x12\x03L\t\x0f\n\x0c\n\x05\x04\x08\
    \x02\0\x03\x12\x03L\x12\x13\n\x0b\n\x04\x04\x08\x02\x01\x12\x03M\x02\x1d\
    \n\x0c\n\x05\x04\x08\x02\x01\x05\x12\x03M\x02\x08\n\x0c\n\x05\x04\x08\
    \x02\x01\x01\x12\x03M\t\x18\n\x0c\n\x05\x04\x08\x02\x01\x03\x12\x03M\x1b\
    \x1c\n\x0b\n\x04\x04\x08\x02\x02\x12\x03N\x02\x1c\n\x0c\n\x05\x04\x08\
    \x02\x02\x05\x12\x03N\x02\x08\n\x0c\n\x05\x04\x08\x02\x02\x01\x12\x03N\t\
    \x17\n\x0c\n\x05\x04\x08\x02\x02\x03\x12\x03N\x1a\x1b\n\x0b\n\x04\x04\
    \x08\x02\x03\x12\x03O\x02\x1c\n\x0c\n\x05\x04\x08\x02\x03\x05\x12\x03O\
    \x02\x08\n\x0c\n\x05\x04\x08\x02\x03\x01\x12\x03O\t\x17\n\x0c\n\x05\x04\
    \x08\x02\x03\x03\x12\x03O\x1a\x1b\n\x0b\n\x04\x04\x08\x02\x04\x12\x03P\
    \x02'\n\x0c\n\x05\x04\x08\x02\x04\x05\x12\x03P\x02\x08\n\x0c\n\x05\x04\
    \x08\x02\x04\x01\x12\x03P\t\"\n\x0c\n\x05\x04\x08\x02\x04\x03\x12\x03P%&\
    \n\x0b\n\x04\x04\x08\x02\x05\x12\x03Q\x02!\n\x0c\n\x05\x04\x08\x02\x05\
    \x06\x12\x03Q\x02\x14\n\x0c\n\x05\x04\x08\x02\x05\x01\x12\x03Q\x15\x1c\n\
    \x0c\n\x05\x04\x08\x02\x05\x03\x12\x03Q\x1f\x20\n\x0b\n\x04\x04\x08\x02\
    \x06\x12\x03R\x02\x1a\n\x0c\n\x05\x04\x08\x02\x06\x06\x12\x03R\x02\x0b\n\
    \x0c\n\x05\x04\x08\x02\x06\x01\x12\x03R\x0c\x15\n\x0c\n\x05\x04\x08\x02\
    \x06\x03\x12\x03R\x18\x19\n\n\n\x02\x04\t\x12\x04U\0a\x01\n\n\n\x03\x04\
    \t\x01\x12\x03U\x08\x10\n\x0c\n\x04\x04\t\x04\0\x12\x04W\x02Z\x03\n\x0c\
    \n\x05\x04\t\x04\0\x01\x12\x03W\x07\x13\n\r\n\x06\x04\t\x04\0\x02\0\x12\
    \x03X\x04\x19\n\x0e\n\x07\x04\t\x04\0\x02\0\x01\x12\x03X\x04\x14\n\x0e\n\
    \x07\x04\t\x04\0\x02\0\x02\x12\x03X\x17\x18\n\r\n\x06\x04\t\x04\0\x02\
    \x01\x12\x03Y\x04\x19\n\x0e\n\x07\x04\t\x04\0\x02\x01\x01\x12\x03Y\x04\
    \x14\n\x0e\n\x07\x04\t\x04\0\x02\x01\x02\x12\x03Y\x17\x18\n\x0b\n\x04\
    \x04\t\x02\0\x12\x03\\\x02\"\n\x0c\n\x05\x04\t\x02\0\x06\x12\x03\\\x02\
    \x0e\n\x0c\n\x05\x04\t\x02\0\x01\x12\x03\\\x0f\x1d\n\x0c\n\x05\x04\t\x02\
    \0\x03\x12\x03\\\x20!\n\x0c\n\x04\x04\t\x08\0\x12\x04]\x02`\x03\n\x0c\n\
    \x05\x04\t\x08\0\x01\x12\x03]\x08\x11\n\x0b\n\x04\x04\t\x02\x01\x12\x03^\
    \x04(\n\x0c\n\x05\x04\t\x02\x01\x06\x12\x03^\x04\x12\n\x0c\n\x05\x04\t\
    \x02\x01\x01\x12\x03^\x13#\n\x0c\n\x05\x04\t\x02\x01\x03\x12\x03^&'\n\
    \x0b\n\x04\x04\t\x02\x02\x12\x03_\x04(\n\x0c\n\x05\x04\t\x02\x02\x06\x12\
    \x03_\x04\x12\n\x0c\n\x05\x04\t\x02\x02\x01\x12\x03_\x13#\n\x0c\n\x05\
    \x04\t\x02\x02\x03\x12\x03_&'\n\n\n\x02\x04\n\x12\x04c\0f\x01\n\n\n\x03\
    \x04\n\x01\x12\x03c\x08\x16\n\x0b\n\x04\x04\n\x02\0\x12\x03d\x02\x18\n\
    \x0c\n\x05\x04\n\x02\0\x05\x12\x03d\x02\x08\n\x0c\n\x05\x04\n\x02\0\x01\
    \x12\x03d\t\x13\n\x0c\n\x05\x04\n\x02\0\x03\x12\x03d\x16\x17\n\x0b\n\x04\
    \x04\n\x02\x01\x12\x03e\x02\x1b\n\x0c\n\x05\x04\n\x02\x01\x06\x12\x03e\
    \x02\x0f\n\x0c\n\x05\x04\n\x02\x01\x01\x12\x03e\x10\x16\n\x0c\n\x05\x04\
    \n\x02\x01\x03\x12\x03e\x19\x1a\n\n\n\x02\x04\x0b\x12\x04h\0k\x01\n\n\n\
    \x03\x04\x0b\x01\x12\x03h\x08\x16\n\x0b\n\x04\x04\x0b\x02\0\x12\x03i\x02\
    /\n\x0c\n\x05\x04\x0b\x02\0\x04\x12\x03i\x02\n\n\x0c\n\x05\x04\x0b\x02\0\
    \x06\x12\x03i\x0b\x19\n\x0c\n\x05\x04\x0b\x02\0\x01\x12\x03i\x1a*\n\x0c\
    \n\x05\x04\x0b\x02\0\x03\x12\x03i-.\n\x0b\n\x04\x04\x0b\x02\x01\x12\x03j\
    \x02\x1c\n\x0c\n\x05\x04\x0b\x02\x01\x04\x12\x03j\x02\n\n\x0c\n\x05\x04\
    \x0b\x02\x01\x06\x12\x03j\x0b\x10\n\x0c\n\x05\x04\x0b\x02\x01\x01\x12\
    \x03j\x11\x17\n\x0c\n\x05\x04\x0b\x02\x01\x03\x12\x03j\x1a\x1b\n\x0b\n\
    \x02\x04\x0c\x12\x05m\0\x81\x01\x01\n\n\n\x03\x04\x0c\x01\x12\x03m\x08\
    \x16\n\x0c\n\x04\x04\x0c\x04\0\x12\x04o\x02v\x03\n\x0c\n\x05\x04\x0c\x04\
    \0\x01\x12\x03o\x07\x19\n\r\n\x06\x04\x0c\x04\0\x02\0\x12\x03p\x04\x16\n\
    \x0e\n\x07\x04\x0c\x04\0\x02\0\x01\x12\x03p\x04\x11\n\x0e\n\x07\x04\x0c\
    \x04\0\x02\0\x02\x12\x03p\x14\x15\n\r\n\x06\x04\x0c\x04\0\x02\x01\x12\
    \x03q\x04\x18\n\x0e\n\x07\x04\x0c\x04\0\x02\x01\x01\x12\x03q\x04\x13\n\
    \x0e\n\x07\x04\x0c\x04\0\x02\x01\x02\x12\x03q\x16\x17\n\r\n\x06\x04\x0c\
    \x04\0\x02\x02\x12\x03r\x04\x1a\n\x0e\n\x07\x04\x0c\x04\0\x02\x02\x01\
    \x12\x03r\x04\x15\n\x0e\n\x07\x04\x0c\x04\0\x02\x02\x02\x12\x03r\x18\x19\
    \n\r\n\x06\x04\x0c\x04\0\x02\x03\x12\x03s\x04\x15\n\x0e\n\x07\x04\x0c\
    \x04\0\x02\x03\x01\x12\x03s\x04\x10\n\x0e\n\x07\x04\x0c\x04\0\x02\x03\
    \x02\x12\x03s\x13\x14\n\r\n\x06\x04\x0c\x04\0\x02\x04\x12\x03t\x04\x17\n\
    \x0e\n\x07\x04\x0c\x04\0\x02\x04\x01\x12\x03t\x04\x12\n\x0e\n\x07\x04\
    \x0c\x04\0\x02\x04\x02\x12\x03t\x15\x16\n\r\n\x06\x04\x0c\x04\0\x02\x05\
    \x12\x03u\x04\x19\n\x0e\n\x07\x04\x0c\x04\0\x02\x05\x01\x12\x03u\x04\x14\
    \n\x0e\n\x07\x04\x0c\x04\0\x02\x05\x02\x12\x03u\x17\x18\n\x0b\n\x04\x04\
    \x0c\x02\0\x12\x03x\x02\x1e\n\x0c\n\x05\x04\x0c\x02\0\x06\x12\x03x\x02\
    \x14\n\x0c\n\x05\x04\x0c\x02\0\x01\x12\x03x\x15\x19\n\x0c\n\x05\x04\x0c\
    \x02\0\x03\x12\x03x\x1c\x1d\n\r\n\x04\x04\x0c\x08\0\x12\x05y\x02\x80\x01\
    \x03\n\x0c\n\x05\x04\x0c\x08\0\x01\x12\x03y\x08\x0e\n\x0b\n\x04\x04\x0c\
    \x02\x01\x12\x03z\x04#\n\x0c\n\x05\x04\x0c\x02\x01\x06\x12\x03z\x04\x10\
    \n\x0c\n\x05\x04\x0c\x02\x01\x01\x12\x03z\x11\x1e\n\x0c\n\x05\x04\x0c\
    \x02\x01\x03\x12\x03z!\"\n\x0b\n\x04\x04\x0c\x02\x02\x12\x03{\x04'\n\x0c\
    \n\x05\x04\x0c\x02\x02\x06\x12\x03{\x04\x12\n\x0c\n\x05\x04\x0c\x02\x02\
    \x01\x12\x03{\x13\"\n\x0c\n\x05\x04\x0c\x02\x02\x03\x12\x03{%&\n\x0b\n\
    \x04\x04\x0c\x02\x03\x12\x03|\x04*\n\x0c\n\x05\x04\x0c\x02\x03\x06\x12\
    \x03|\x04\x13\n\x0c\n\x05\x04\x0c\x02\x03\x01\x12\x03|\x14%\n\x0c\n\x05\
    \x04\x0c\x02\x03\x03\x12\x03|()\n\x0b\n\x04\x04\x0c\x02\x04\x12\x03}\x04\
    !\n\x0c\n\x05\x04\x0c\x02\x04\x06\x12\x03}\x04\x0f\n\x0c\n\x05\x04\x0c\
    \x02\x04\x01\x12\x03}\x10\x1c\n\x0c\n\x05\x04\x0c\x02\x04\x03\x12\x03}\
    \x1f\x20\n\x0b\n\x04\x04\x0c\x02\x05\x12\x03~\x04%\n\x0c\n\x05\x04\x0c\
    \x02\x05\x06\x12\x03~\x04\x11\n\x0c\n\x05\x04\x0c\x02\x05\x01\x12\x03~\
    \x12\x20\n\x0c\n\x05\x04\x0c\x02\x05\x03\x12\x03~#$\n\x0b\n\x04\x04\x0c\
    \x02\x06\x12\x03\x7f\x04(\n\x0c\n\x05\x04\x0c\x02\x06\x06\x12\x03\x7f\
    \x04\x12\n\x0c\n\x05\x04\x0c\x02\x06\x01\x12\x03\x7f\x13#\n\x0c\n\x05\
    \x04\x0c\x02\x06\x03\x12\x03\x7f&'\n\x0c\n\x02\x04\r\x12\x06\x83\x01\0\
    \x87\x01\x01\n\x0b\n\x03\x04\r\x01\x12\x04\x83\x01\x08\x14\n\x0c\n\x04\
    \x04\r\x02\0\x12\x04\x84\x01\x02\x15\n\r\n\x05\x04\r\x02\0\x05\x12\x04\
    \x84\x01\x02\x08\n\r\n\x05\x04\r\x02\0\x01\x12\x04\x84\x01\t\x10\n\r\n\
    \x05\x04\r\x02\0\x03\x12\x04\x84\x01\x13\x14\n\x0c\n\x04\x04\r\x02\x01\
    \x12\x04\x85\x01\x02\x1c\n\r\n\x05\x04\r\x02\x01\x05\x12\x04\x85\x01\x02\
    \x08\n\r\n\x05\x04\r\x02\x01\x01\x12\x04\x85\x01\t\x17\n\r\n\x05\x04\r\
    \x02\x01\x03\x12\x04\x85\x01\x1a\x1b\n\x0c\n\x04\x04\r\x02\x02\x12\x04\
    \x86\x01\x02\x1a\n\r\n\x05\x04\r\x02\x02\x06\x12\x04\x86\x01\x02\x0e\n\r\
    \n\x05\x04\r\x02\x02\x01\x12\x04\x86\x01\x0f\x15\n\r\n\x05\x04\r\x02\x02\
    \x03\x12\x04\x86\x01\x18\x19\n\x0c\n\x02\x04\x0e\x12\x06\x89\x01\0\x8d\
    \x01\x01\n\x0b\n\x03\x04\x0e\x01\x12\x04\x89\x01\x08\x16\n\x0c\n\x04\x04\
    \x0e\x02\0\x12\x04\x8a\x01\x02\x15\n\r\n\x05\x04\x0e\x02\0\x05\x12\x04\
    \x8a\x01\x02\x08\n\r\n\x05\x04\x0e\x02\0\x01\x12\x04\x8a\x01\t\x10\n\r\n\
    \x05\x04\x0e\x02\0\x03\x12\x04\x8a\x01\x13\x14\n\x0c\n\x04\x04\x0e\x02\
    \x01\x12\x04\x8b\x01\x02\x1c\n\r\n\x05\x04\x0e\x02\x01\x05\x12\x04\x8b\
    \x01\x02\x08\n\r\n\x05\x04\x0e\x02\x01\x01\x12\x04\x8b\x01\t\x17\n\r\n\
    \x05\x04\x0e\x02\x01\x03\x12\x04\x8b\x01\x1a\x1b\n\x0c\n\x04\x04\x0e\x02\
    \x02\x12\x04\x8c\x01\x02\x1d\n\r\n\x05\x04\x0e\x02\x02\x06\x12\x04\x8c\
    \x01\x02\x0f\n\r\n\x05\x04\x0e\x02\x02\x01\x12\x04\x8c\x01\x10\x18\n\r\n\
    \x05\x04\x0e\x02\x02\x03\x12\x04\x8c\x01\x1b\x1c\n\x0c\n\x02\x04\x0f\x12\
    \x06\x8f\x01\0\x93\x01\x01\n\x0b\n\x03\x04\x0f\x01\x12\x04\x8f\x01\x08\
    \x17\n\x0c\n\x04\x04\x0f\x02\0\x12\x04\x90\x01\x02\x1c\n\r\n\x05\x04\x0f\
    \x02\0\x05\x12\x04\x90\x01\x02\x08\n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\
    \x90\x01\t\x17\n\r\n\x05\x04\x0f\x02\0\x03\x12\x04\x90\x01\x1a\x1b\n\x0c\
    \n\x04\x04\x0f\x02\x01\x12\x04\x91\x01\x02\x14\n\r\n\x05\x04\x0f\x02\x01\
    \x05\x12\x04\x91\x01\x02\x08\n\r\n\x05\x04\x0f\x02\x01\x01\x12\x04\x91\
    \x01\t\x0f\n\r\n\x05\x04\x0f\x02\x01\x03\x12\x04\x91\x01\x12\x13\n\x0c\n\
    \x04\x04\x0f\x02\x02\x12\x04\x92\x01\x02\x11\n\r\n\x05\x04\x0f\x02\x02\
    \x05\x12\x04\x92\x01\x02\x08\n\r\n\x05\x04\x0f\x02\x02\x01\x12\x04\x92\
    \x01\t\x0c\n\r\n\x05\x04\x0f\x02\x02\x03\x12\x04\x92\x01\x0f\x10\n\x0c\n\
    \x02\x04\x10\x12\x06\x95\x01\0\x99\x01\x01\n\x0b\n\x03\x04\x10\x01\x12\
    \x04\x95\x01\x08\x13\n\x0c\n\x04\x04\x10\x02\0\x12\x04\x96\x01\x02\x15\n\
    \r\n\x05\x04\x10\x02\0\x05\x12\x04\x96\x01\x02\x08\n\r\n\x05\x04\x10\x02\
    \0\x01\x12\x04\x96\x01\t\x10\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\x96\x01\
    \x13\x14\n\x0c\n\x04\x04\x10\x02\x01\x12\x04\x97\x01\x02\x1c\n\r\n\x05\
    \x04\x10\x02\x01\x05\x12\x04\x97\x01\x02\x08\n\r\n\x05\x04\x10\x02\x01\
    \x01\x12\x04\x97\x01\t\x17\n\r\n\x05\x04\x10\x02\x01\x03\x12\x04\x97\x01\
    \x1a\x1b\n\x0c\n\x04\x04\x10\x02\x02\x12\x04\x98\x01\x02\x12\n\r\n\x05\
    \x04\x10\x02\x02\x05\x12\x04\x98\x01\x02\x08\n\r\n\x05\x04\x10\x02\x02\
    \x01\x12\x04\x98\x01\t\r\n\r\n\x05\x04\x10\x02\x02\x03\x12\x04\x98\x01\
    \x10\x11\n\x0c\n\x02\x04\x11\x12\x06\x9b\x01\0\x9f\x01\x01\n\x0b\n\x03\
    \x04\x11\x01\x12\x04\x9b\x01\x08\x15\n\x0c\n\x04\x04\x11\x02\0\x12\x04\
    \x9c\x01\x02\x15\n\r\n\x05\x04\x11\x02\0\x05\x12\x04\x9c\x01\x02\x08\n\r\
    \n\x05\x04\x11\x02\0\x01\x12\x04\x9c\x01\t\x10\n\r\n\x05\x04\x11\x02\0\
    \x03\x12\x04\x9c\x01\x13\x14\n\x0c\n\x04\x04\x11\x02\x01\x12\x04\x9d\x01\
    \x02\x1c\n\r\n\x05\x04\x11\x02\x01\x05\x12\x04\x9d\x01\x02\x08\n\r\n\x05\
    \x04\x11\x02\x01\x01\x12\x04\x9d\x01\t\x17\n\r\n\x05\x04\x11\x02\x01\x03\
    \x12\x04\x9d\x01\x1a\x1b\n\x0c\n\x04\x04\x11\x02\x02\x12\x04\x9e\x01\x02\
    \x18\n\r\n\x05\x04\x11\x02\x02\x06\x12\x04\x9e\x01\x02\x0e\n\r\n\x05\x04\
    \x11\x02\x02\x01\x12\x04\x9e\x01\x0f\x13\n\r\n\x05\x04\x11\x02\x02\x03\
    \x12\x04\x9e\x01\x16\x17\n\x0c\n\x02\x04\x12\x12\x06\xa1\x01\0\xa6\x01\
    \x01\n\x0b\n\x03\x04\x12\x01\x12\x04\xa1\x01\x08\x16\n\x0c\n\x04\x04\x12\
    \x02\0\x12\x04\xa2\x01\x02\x1c\n\r\n\x05\x04\x12\x02\0\x05\x12\x04\xa2\
    \x01\x02\x08\n\r\n\x05\x04\x12\x02\0\x01\x12\x04\xa2\x01\t\x17\n\r\n\x05\
    \x04\x12\x02\0\x03\x12\x04\xa2\x01\x1a\x1b\n\x0c\n\x04\x04\x12\x02\x01\
    \x12\x04\xa3\x01\x02\x14\n\r\n\x05\x04\x12\x02\x01\x05\x12\x04\xa3\x01\
    \x02\x08\n\r\n\x05\x04\x12\x02\x01\x01\x12\x04\xa3\x01\t\x0f\n\r\n\x05\
    \x04\x12\x02\x01\x03\x12\x04\xa3\x01\x12\x13\n\x0c\n\x04\x04\x12\x02\x02\
    \x12\x04\xa4\x01\x02\x11\n\r\n\x05\x04\x12\x02\x02\x05\x12\x04\xa4\x01\
    \x02\x08\n\r\n\x05\x04\x12\x02\x02\x01\x12\x04\xa4\x01\t\x0c\n\r\n\x05\
    \x04\x12\x02\x02\x03\x12\x04\xa4\x01\x0f\x10\n\x0c\n\x04\x04\x12\x02\x03\
    \x12\x04\xa5\x01\x02\x13\n\r\n\x05\x04\x12\x02\x03\x05\x12\x04\xa5\x01\
    \x02\x08\n\r\n\x05\x04\x12\x02\x03\x01\x12\x04\xa5\x01\t\x0e\n\r\n\x05\
    \x04\x12\x02\x03\x03\x12\x04\xa5\x01\x11\x12\n\x0c\n\x02\x04\x13\x12\x06\
    \xa8\x01\0\xb8\x01\x01\n\x0b\n\x03\x04\x13\x01\x12\x04\xa8\x01\x08\x1a\n\
    \x0e\n\x04\x04\x13\x04\0\x12\x06\xaa\x01\x02\xaf\x01\x03\n\r\n\x05\x04\
    \x13\x04\0\x01\x12\x04\xaa\x01\x07\x12\n\x0e\n\x06\x04\x13\x04\0\x02\0\
    \x12\x04\xab\x01\x04\x20\n\x0f\n\x07\x04\x13\x04\0\x02\0\x01\x12\x04\xab\
    \x01\x04\x1b\n\x0f\n\x07\x04\x13\x04\0\x02\0\x02\x12\x04\xab\x01\x1e\x1f\
    \n\x0e\n\x06\x04\x13\x04\0\x02\x01\x12\x04\xac\x01\x04\x17\n\x0f\n\x07\
    \x04\x13\x04\0\x02\x01\x01\x12\x04\xac\x01\x04\x12\n\x0f\n\x07\x04\x13\
    \x04\0\x02\x01\x02\x12\x04\xac\x01\x15\x16\n\x0e\n\x06\x04\x13\x04\0\x02\
    \x02\x12\x04\xad\x01\x04\x1e\n\x0f\n\x07\x04\x13\x04\0\x02\x02\x01\x12\
    \x04\xad\x01\x04\x19\n\x0f\n\x07\x04\x13\x04\0\x02\x02\x02\x12\x04\xad\
    \x01\x1c\x1d\n\x0e\n\x06\x04\x13\x04\0\x02\x03\x12\x04\xae\x01\x04\x1a\n\
    \x0f\n\x07\x04\x13\x04\0\x02\x03\x01\x12\x04\xae\x01\x04\x15\n\x0f\n\x07\
    \x04\x13\x04\0\x02\x03\x02\x12\x04\xae\x01\x18\x19\n\x0c\n\x04\x04\x13\
    \x02\0\x12\x04\xb1\x01\x02\x17\n\r\n\x05\x04\x13\x02\0\x06\x12\x04\xb1\
    \x01\x02\r\n\r\n\x05\x04\x13\x02\0\x01\x12\x04\xb1\x01\x0e\x12\n\r\n\x05\
    \x04\x13\x02\0\x03\x12\x04\xb1\x01\x15\x16\n\x0e\n\x04\x04\x13\x08\0\x12\
    \x06\xb2\x01\x02\xb7\x01\x03\n\r\n\x05\x04\x13\x08\0\x01\x12\x04\xb2\x01\
    \x08\x0f\n\x0c\n\x04\x04\x13\x02\x01\x12\x04\xb3\x01\x046\n\r\n\x05\x04\
    \x13\x02\x01\x06\x12\x04\xb3\x01\x04\x19\n\r\n\x05\x04\x13\x02\x01\x01\
    \x12\x04\xb3\x01\x1a1\n\r\n\x05\x04\x13\x02\x01\x03\x12\x04\xb3\x0145\n\
    \x0c\n\x04\x04\x13\x02\x02\x12\x04\xb4\x01\x04%\n\r\n\x05\x04\x13\x02\
    \x02\x06\x12\x04\xb4\x01\x04\x11\n\r\n\x05\x04\x13\x02\x02\x01\x12\x04\
    \xb4\x01\x12\x20\n\r\n\x05\x04\x13\x02\x02\x03\x12\x04\xb4\x01#$\n\x0c\n\
    \x04\x04\x13\x02\x03\x12\x04\xb5\x01\x042\n\r\n\x05\x04\x13\x02\x03\x06\
    \x12\x04\xb5\x01\x04\x17\n\r\n\x05\x04\x13\x02\x03\x01\x12\x04\xb5\x01\
    \x18-\n\r\n\x05\x04\x13\x02\x03\x03\x12\x04\xb5\x0101\n\x0c\n\x04\x04\
    \x13\x02\x04\x12\x04\xb6\x01\x04*\n\r\n\x05\x04\x13\x02\x04\x06\x12\x04\
    \xb6\x01\x04\x13\n\r\n\x05\x04\x13\x02\x04\x01\x12\x04\xb6\x01\x14%\n\r\
    \n\x05\x04\x13\x02\x04\x03\x12\x04\xb6\x01()\n\x0c\n\x02\x04\x14\x12\x06\
    \xba\x01\0\xbe\x01\x01\n\x0b\n\x03\x04\x14\x01\x12\x04\xba\x01\x08\x1d\n\
    \x0c\n\x04\x04\x14\x02\0\x12\x04\xbb\x01\x02\x20\n\r\n\x05\x04\x14\x02\0\
    \x06\x12\x04\xbb\x01\x02\x12\n\r\n\x05\x04\x14\x02\0\x01\x12\x04\xbb\x01\
    \x13\x1b\n\r\n\x05\x04\x14\x02\0\x03\x12\x04\xbb\x01\x1e\x1f\n\x0c\n\x04\
    \x04\x14\x02\x01\x12\x04\xbc\x01\x02%\n\r\n\x05\x04\x14\x02\x01\x04\x12\
    \x04\xbc\x01\x02\n\n\r\n\x05\x04\x14\x02\x01\x05\x12\x04\xbc\x01\x0b\x11\
    \n\r\n\x05\x04\x14\x02\x01\x01\x12\x04\xbc\x01\x12\x20\n\r\n\x05\x04\x14\
    \x02\x01\x03\x12\x04\xbc\x01#$\n\x0c\n\x04\x04\x14\x02\x02\x12\x04\xbd\
    \x01\x02\x20\n\r\n\x05\x04\x14\x02\x02\x04\x12\x04\xbd\x01\x02\n\n\r\n\
    \x05\x04\x14\x02\x02\x05\x12\x04\xbd\x01\x0b\x11\n\r\n\x05\x04\x14\x02\
    \x02\x01\x12\x04\xbd\x01\x12\x1b\n\r\n\x05\x04\x14\x02\x02\x03\x12\x04\
    \xbd\x01\x1e\x1f\n\x0c\n\x02\x04\x15\x12\x06\xc0\x01\0\xc4\x01\x01\n\x0b\
    \n\x03\x04\x15\x01\x12\x04\xc0\x01\x08\x15\n\x0c\n\x04\x04\x15\x02\0\x12\
    \x04\xc1\x01\x02\x12\n\r\n\x05\x04\x15\x02\0\x05\x12\x04\xc1\x01\x02\x08\
    \n\r\n\x05\x04\x15\x02\0\x01\x12\x04\xc1\x01\t\r\n\r\n\x05\x04\x15\x02\0\
    \x03\x12\x04\xc1\x01\x10\x11\n\x0c\n\x04\x04\x15\x02\x01\x12\x04\xc2\x01\
    \x02%\n\r\n\x05\x04\x15\x02\x01\x04\x12\x04\xc2\x01\x02\n\n\r\n\x05\x04\
    \x15\x02\x01\x05\x12\x04\xc2\x01\x0b\x11\n\r\n\x05\x04\x15\x02\x01\x01\
    \x12\x04\xc2\x01\x12\x20\n\r\n\x05\x04\x15\x02\x01\x03\x12\x04\xc2\x01#$\
    \n\x0c\n\x04\x04\x15\x02\x02\x12\x04\xc3\x01\x02\x20\n\r\n\x05\x04\x15\
    \x02\x02\x04\x12\x04\xc3\x01\x02\n\n\r\n\x05\x04\x15\x02\x02\x05\x12\x04\
    \xc3\x01\x0b\x11\n\r\n\x05\x04\x15\x02\x02\x01\x12\x04\xc3\x01\x12\x1b\n\
    \r\n\x05\x04\x15\x02\x02\x03\x12\x04\xc3\x01\x1e\x1f\n\x0c\n\x02\x04\x16\
    \x12\x06\xc6\x01\0\xc8\x01\x01\n\x0b\n\x03\x04\x16\x01\x12\x04\xc6\x01\
    \x08\x1b\n\x0c\n\x04\x04\x16\x02\0\x12\x04\xc7\x01\x02\x1e\n\r\n\x05\x04\
    \x16\x02\0\x04\x12\x04\xc7\x01\x02\n\n\r\n\x05\x04\x16\x02\0\x05\x12\x04\
    \xc7\x01\x0b\x11\n\r\n\x05\x04\x16\x02\0\x01\x12\x04\xc7\x01\x12\x19\n\r\
    \n\x05\x04\x16\x02\0\x03\x12\x04\xc7\x01\x1c\x1d\n\x0c\n\x02\x04\x17\x12\
    \x06\xca\x01\0\xcc\x01\x01\n\x0b\n\x03\x04\x17\x01\x12\x04\xca\x01\x08\
    \x17\n\x0c\n\x04\x04\x17\x02\0\x12\x04\xcb\x01\x02\x19\n\r\n\x05\x04\x17\
    \x02\0\x06\x12\x04\xcb\x01\x02\n\n\r\n\x05\x04\x17\x02\0\x01\x12\x04\xcb\
    \x01\x0b\x14\n\r\n\x05\x04\x17\x02\0\x03\x12\x04\xcb\x01\x17\x18\n\x0c\n\
    \x02\x04\x18\x12\x06\xce\x01\0\xd1\x01\x01\n\x0b\n\x03\x04\x18\x01\x12\
    \x04\xce\x01\x08\x18\n\x0c\n\x04\x04\x18\x02\0\x12\x04\xcf\x01\x02\x1a\n\
    \r\n\x05\x04\x18\x02\0\x06\x12\x04\xcf\x01\x02\x0e\n\r\n\x05\x04\x18\x02\
    \0\x01\x12\x04\xcf\x01\x0f\x15\n\r\n\x05\x04\x18\x02\0\x03\x12\x04\xcf\
    \x01\x18\x19\n\x0c\n\x04\x04\x18\x02\x01\x12\x04\xd0\x01\x02\x12\n\r\n\
    \x05\x04\x18\x02\x01\x05\x12\x04\xd0\x01\x02\x08\n\r\n\x05\x04\x18\x02\
    \x01\x01\x12\x04\xd0\x01\t\r\n\r\n\x05\x04\x18\x02\x01\x03\x12\x04\xd0\
    \x01\x10\x11\n\x0c\n\x02\x04\x19\x12\x06\xd3\x01\0\xd6\x01\x01\n\x0b\n\
    \x03\x04\x19\x01\x12\x04\xd3\x01\x08\x14\n\x0c\n\x04\x04\x19\x02\0\x12\
    \x04\xd4\x01\x02\x19\n\r\n\x05\x04\x19\x02\0\x06\x12\x04\xd4\x01\x02\x0f\
    \n\r\n\x05\x04\x19\x02\0\x01\x12\x04\xd4\x01\x10\x14\n\r\n\x05\x04\x19\
    \x02\0\x03\x12\x04\xd4\x01\x17\x18\n\x0c\n\x04\x04\x19\x02\x01\x12\x04\
    \xd5\x01\x02\x12\n\r\n\x05\x04\x19\x02\x01\x05\x12\x04\xd5\x01\x02\x08\n\
    \r\n\x05\x04\x19\x02\x01\x01\x12\x04\xd5\x01\t\r\n\r\n\x05\x04\x19\x02\
    \x01\x03\x12\x04\xd5\x01\x10\x11\n\x0c\n\x02\x04\x1a\x12\x06\xd8\x01\0\
    \xdb\x01\x01\n\x0b\n\x03\x04\x1a\x01\x12\x04\xd8\x01\x08\x14\n\x0c\n\x04\
    \x04\x1a\x02\0\x12\x04\xd9\x01\x02\x15\n\r\n\x05\x04\x1a\x02\0\x05\x12\
    \x04\xd9\x01\x02\x08\n\r\n\x05\x04\x1a\x02\0\x01\x12\x04\xd9\x01\t\x10\n\
    \r\n\x05\x04\x1a\x02\0\x03\x12\x04\xd9\x01\x13\x14\n\x0c\n\x04\x04\x1a\
    \x02\x01\x12\x04\xda\x01\x02\x12\n\r\n\x05\x04\x1a\x02\x01\x05\x12\x04\
    \xda\x01\x02\x08\n\r\n\x05\x04\x1a\x02\x01\x01\x12\x04\xda\x01\t\r\n\r\n\
    \x05\x04\x1a\x02\x01\x03\x12\x04\xda\x01\x10\x11\n\x0c\n\x02\x04\x1b\x12\
    \x06\xdd\x01\0\xe2\x01\x01\n\x0b\n\x03\x04\x1b\x01\x12\x04\xdd\x01\x08\
    \x15\n\x0c\n\x04\x04\x1b\x02\0\x12\x04\xde\x01\x02\x15\n\r\n\x05\x04\x1b\
    \x02\0\x05\x12\x04\xde\x01\x02\x08\n\r\n\x05\x04\x1b\x02\0\x01\x12\x04\
    \xde\x01\t\x10\n\r\n\x05\x04\x1b\x02\0\x03\x12\x04\xde\x01\x13\x14\n\x0c\
    \n\x04\x04\x1b\x02\x01\x12\x04\xdf\x01\x02\x14\n\r\n\x05\x04\x1b\x02\x01\
    \x05\x12\x04\xdf\x01\x02\x08\n\r\n\x05\x04\x1b\x02\x01\x01\x12\x04\xdf\
    \x01\t\x0f\n\r\n\x05\x04\x1b\x02\x01\x03\x12\x04\xdf\x01\x12\x13\n\x0c\n\
    \x04\x04\x1b\x02\x02\x12\x04\xe0\x01\x02\x12\n\r\n\x05\x04\x1b\x02\x02\
    \x05\x12\x04\xe0\x01\x02\x08\n\r\n\x05\x04\x1b\x02\x02\x01\x12\x04\xe0\
    \x01\t\r\n\r\n\x05\x04\x1b\x02\x02\x03\x12\x04\xe0\x01\x10\x11\n\x0c\n\
    \x04\x04\x1b\x02\x03\x12\x04\xe1\x01\x02*\n\r\n\x05\x04\x1b\x02\x03\x04\
    \x12\x04\xe1\x01\x02\n\n\r\n\x05\x04\x1b\x02\x03\x05\x12\x04\xe1\x01\x0b\
    \x11\n\r\n\x05\x04\x1b\x02\x03\x01\x12\x04\xe1\x01\x12%\n\r\n\x05\x04\
    \x1b\x02\x03\x03\x12\x04\xe1\x01()\n\x0c\n\x02\x04\x1c\x12\x06\xe4\x01\0\
    \xf2\x01\x01\n\x0b\n\x03\x04\x1c\x01\x12\x04\xe4\x01\x08\x11\n\x0e\n\x04\
    \x04\x1c\x04\0\x12\x06\xe6\x01\x02\xea\x01\x03\n\r\n\x05\x04\x1c\x04\0\
    \x01\x12\x04\xe6\x01\x07\x14\n\x0e\n\x06\x04\x1c\x04\0\x02\0\x12\x04\xe7\
    \x01\x04\x0b\n\x0f\n\x07\x04\x1c\x04\0\x02\0\x01\x12\x04\xe7\x01\x04\x06\
    \n\x0f\n\x07\x04\x1c\x04\0\x02\0\x02\x12\x04\xe7\x01\t\n\n\x0e\n\x06\x04\
    \x1c\x04\0\x02\x01\x12\x04\xe8\x01\x04\x11\n\x0f\n\x07\x04\x1c\x04\0\x02\
    \x01\x01\x12\x04\xe8\x01\x04\x0c\n\x0f\n\x07\x04\x1c\x04\0\x02\x01\x02\
    \x12\x04\xe8\x01\x0f\x10\n\x0e\n\x06\x04\x1c\x04\0\x02\x02\x12\x04\xe9\
    \x01\x04\x14\n\x0f\n\x07\x04\x1c\x04\0\x02\x02\x01\x12\x04\xe9\x01\x04\
    \x0f\n\x0f\n\x07\x04\x1c\x04\0\x02\x02\x02\x12\x04\xe9\x01\x12\x13\n\x0c\
    \n\x04\x04\x1c\x02\0\x12\x04\xec\x01\x02\x19\n\r\n\x05\x04\x1c\x02\0\x06\
    \x12\x04\xec\x01\x02\x0f\n\r\n\x05\x04\x1c\x02\0\x01\x12\x04\xec\x01\x10\
    \x14\n\r\n\x05\x04\x1c\x02\0\x03\x12\x04\xec\x01\x17\x18\n\x0e\n\x04\x04\
    \x1c\x08\0\x12\x06\xed\x01\x02\xf1\x01\x03\n\r\n\x05\x04\x1c\x08\0\x01\
    \x12\x04\xed\x01\x08\x11\n\x0c\n\x04\x04\x1c\x02\x01\x12\x04\xee\x01\x04\
    \x1c\n\r\n\x05\x04\x1c\x02\x01\x06\x12\x04\xee\x01\x04\x14\n\r\n\x05\x04\
    \x1c\x02\x01\x01\x12\x04\xee\x01\x15\x17\n\r\n\x05\x04\x1c\x02\x01\x03\
    \x12\x04\xee\x01\x1a\x1b\n\x0c\n\x04\x04\x1c\x02\x02\x12\x04\xef\x01\x04\
    '\n\r\n\x05\x04\x1c\x02\x02\x06\x12\x04\xef\x01\x04\x19\n\r\n\x05\x04\
    \x1c\x02\x02\x01\x12\x04\xef\x01\x1a\"\n\r\n\x05\x04\x1c\x02\x02\x03\x12\
    \x04\xef\x01%&\n\x0c\n\x04\x04\x1c\x02\x03\x12\x04\xf0\x01\x04(\n\r\n\
    \x05\x04\x1c\x02\x03\x06\x12\x04\xf0\x01\x04\x17\n\r\n\x05\x04\x1c\x02\
    \x03\x01\x12\x04\xf0\x01\x18#\n\r\n\x05\x04\x1c\x02\x03\x03\x12\x04\xf0\
    \x01&'\n\x0c\n\x02\x04\x1d\x12\x06\xf4\x01\0\xf7\x01\x01\n\x0b\n\x03\x04\
    \x1d\x01\x12\x04\xf4\x01\x08\x18\n\x0c\n\x04\x04\x1d\x02\0\x12\x04\xf5\
    \x01\x02\x18\n\r\n\x05\x04\x1d\x02\0\x05\x12\x04\xf5\x01\x02\x08\n\r\n\
    \x05\x04\x1d\x02\0\x01\x12\x04\xf5\x01\t\x13\n\r\n\x05\x04\x1d\x02\0\x03\
    \x12\x04\xf5\x01\x16\x17\n\x0c\n\x04\x04\x1d\x02\x01\x12\x04\xf6\x01\x02\
    \x17\n\r\n\x05\x04\x1d\x02\x01\x05\x12\x04\xf6\x01\x02\x08\n\r\n\x05\x04\
    \x1d\x02\x01\x01\x12\x04\xf6\x01\t\x12\n\r\n\x05\x04\x1d\x02\x01\x03\x12\
    \x04\xf6\x01\x15\x16\n\x0c\n\x02\x04\x1e\x12\x06\xf9\x01\0\xfe\x01\x01\n\
    \x0b\n\x03\x04\x1e\x01\x12\x04\xf9\x01\x08\x1d\n\x0c\n\x04\x04\x1e\x02\0\
    \x12\x04\xfa\x01\x02\"\n\r\n\x05\x04\x1e\x02\0\x04\x12\x04\xfa\x01\x02\n\
    \n\r\n\x05\x04\x1e\x02\0\x05\x12\x04\xfa\x01\x0b\x11\n\r\n\x05\x04\x1e\
    \x02\0\x01\x12\x04\xfa\x01\x12\x1d\n\r\n\x05\x04\x1e\x02\0\x03\x12\x04\
    \xfa\x01\x20!\n\x0c\n\x04\x04\x1e\x02\x01\x12\x04\xfb\x01\x02!\n\r\n\x05\
    \x04\x1e\x02\x01\x04\x12\x04\xfb\x01\x02\n\n\r\n\x05\x04\x1e\x02\x01\x05\
    \x12\x04\xfb\x01\x0b\x11\n\r\n\x05\x04\x1e\x02\x01\x01\x12\x04\xfb\x01\
    \x12\x1c\n\r\n\x05\x04\x1e\x02\x01\x03\x12\x04\xfb\x01\x1f\x20\n\x0c\n\
    \x04\x04\x1e\x02\x02\x12\x04\xfc\x01\x02\x17\n\r\n\x05\x04\x1e\x02\x02\
    \x05\x12\x04\xfc\x01\x02\x08\n\r\n\x05\x04\x1e\x02\x02\x01\x12\x04\xfc\
    \x01\t\x12\n\r\n\x05\x04\x1e\x02\x02\x03\x12\x04\xfc\x01\x15\x16\n\x0c\n\
    \x04\x04\x1e\x02\x03\x12\x04\xfd\x01\x02\x14\n\r\n\x05\x04\x1e\x02\x03\
    \x05\x12\x04\xfd\x01\x02\x08\n\r\n\x05\x04\x1e\x02\x03\x01\x12\x04\xfd\
    \x01\t\x0f\n\r\n\x05\x04\x1e\x02\x03\x03\x12\x04\xfd\x01\x12\x13\n\x0c\n\
    \x02\x04\x1f\x12\x06\x80\x02\0\x84\x02\x01\n\x0b\n\x03\x04\x1f\x01\x12\
    \x04\x80\x02\x08\x1b\n\x0c\n\x04\x04\x1f\x02\0\x12\x04\x81\x02\x02\x1e\n\
    \r\n\x05\x04\x1f\x02\0\x06\x12\x04\x81\x02\x02\x12\n\r\n\x05\x04\x1f\x02\
    \0\x01\x12\x04\x81\x02\x13\x19\n\r\n\x05\x04\x1f\x02\0\x03\x12\x04\x81\
    \x02\x1c\x1d\n\x0c\n\x04\x04\x1f\x02\x01\x12\x04\x82\x02\x021\n\r\n\x05\
    \x04\x1f\x02\x01\x04\x12\x04\x82\x02\x02\n\n\r\n\x05\x04\x1f\x02\x01\x05\
    \x12\x04\x82\x02\x0b\x11\n\r\n\x05\x04\x1f\x02\x01\x01\x12\x04\x82\x02\
    \x12,\n\r\n\x05\x04\x1f\x02\x01\x03\x12\x04\x82\x02/0\n\x0c\n\x04\x04\
    \x1f\x02\x02\x12\x04\x83\x02\x022\n\r\n\x05\x04\x1f\x02\x02\x04\x12\x04\
    \x83\x02\x02\n\n\r\n\x05\x04\x1f\x02\x02\x06\x12\x04\x83\x02\x0b\x1b\n\r\
    \n\x05\x04\x1f\x02\x02\x01\x12\x04\x83\x02\x1c-\n\r\n\x05\x04\x1f\x02\
    \x02\x03\x12\x04\x83\x0201\n\x0c\n\x02\x04\x20\x12\x06\x86\x02\0\x92\x02\
    \x01\n\x0b\n\x03\x04\x20\x01\x12\x04\x86\x02\x08\x18\n\x0e\n\x04\x04\x20\
    \x04\0\x12\x06\x88\x02\x02\x8b\x02\x03\n\r\n\x05\x04\x20\x04\0\x01\x12\
    \x04\x88\x02\x07\x1b\n\x0e\n\x06\x04\x20\x04\0\x02\0\x12\x04\x89\x02\x04\
    \x0b\n\x0f\n\x07\x04\x20\x04\0\x02\0\x01\x12\x04\x89\x02\x04\x06\n\x0f\n\
    \x07\x04\x20\x04\0\x02\0\x02\x12\x04\x89\x02\t\n\n\x0e\n\x06\x04\x20\x04\
    \0\x02\x01\x12\x04\x8a\x02\x04\x11\n\x0f\n\x07\x04\x20\x04\0\x02\x01\x01\
    \x12\x04\x8a\x02\x04\x0c\n\x0f\n\x07\x04\x20\x04\0\x02\x01\x02\x12\x04\
    \x8a\x02\x0f\x10\n\x0c\n\x04\x04\x20\x02\0\x12\x04\x8d\x02\x02\x20\n\r\n\
    \x05\x04\x20\x02\0\x06\x12\x04\x8d\x02\x02\x16\n\r\n\x05\x04\x20\x02\0\
    \x01\x12\x04\x8d\x02\x17\x1b\n\r\n\x05\x04\x20\x02\0\x03\x12\x04\x8d\x02\
    \x1e\x1f\n\x0e\n\x04\x04\x20\x08\0\x12\x06\x8e\x02\x02\x91\x02\x03\n\r\n\
    \x05\x04\x20\x08\0\x01\x12\x04\x8e\x02\x08\x11\n\x0c\n\x04\x04\x20\x02\
    \x01\x12\x04\x8f\x02\x04\x1c\n\r\n\x05\x04\x20\x02\x01\x06\x12\x04\x8f\
    \x02\x04\x14\n\r\n\x05\x04\x20\x02\x01\x01\x12\x04\x8f\x02\x15\x17\n\r\n\
    \x05\x04\x20\x02\x01\x03\x12\x04\x8f\x02\x1a\x1b\n\x0c\n\x04\x04\x20\x02\
    \x02\x12\x04\x90\x02\x04'\n\r\n\x05\x04\x20\x02\x02\x06\x12\x04\x90\x02\
    \x04\x19\n\r\n\x05\x04\x20\x02\x02\x01\x12\x04\x90\x02\x1a\"\n\r\n\x05\
    \x04\x20\x02\x02\x03\x12\x04\x90\x02%&b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(33);
            messages.push(Transaction::generated_message_descriptor_data());
            messages.push(BlockMetadataTransaction::generated_message_descriptor_data());
            messages.push(GenesisTransaction::generated_message_descriptor_data());
            messages.push(StateCheckpointTransaction::generated_message_descriptor_data());
            messages.push(UserTransaction::generated_message_descriptor_data());
            messages.push(Event::generated_message_descriptor_data());
            messages.push(TransactionInfo::generated_message_descriptor_data());
            messages.push(EventKey::generated_message_descriptor_data());
            messages.push(UserTransactionRequest::generated_message_descriptor_data());
            messages.push(WriteSet::generated_message_descriptor_data());
            messages.push(ScriptWriteSet::generated_message_descriptor_data());
            messages.push(DirectWriteSet::generated_message_descriptor_data());
            messages.push(WriteSetChange::generated_message_descriptor_data());
            messages.push(DeleteModule::generated_message_descriptor_data());
            messages.push(DeleteResource::generated_message_descriptor_data());
            messages.push(DeleteTableItem::generated_message_descriptor_data());
            messages.push(WriteModule::generated_message_descriptor_data());
            messages.push(WriteResource::generated_message_descriptor_data());
            messages.push(WriteTableItem::generated_message_descriptor_data());
            messages.push(TransactionPayload::generated_message_descriptor_data());
            messages.push(ScriptFunctionPayload::generated_message_descriptor_data());
            messages.push(ScriptPayload::generated_message_descriptor_data());
            messages.push(ModuleBundlePayload::generated_message_descriptor_data());
            messages.push(WriteSetPayload::generated_message_descriptor_data());
            messages.push(ScriptFunctionId::generated_message_descriptor_data());
            messages.push(MoveResource::generated_message_descriptor_data());
            messages.push(MoveModuleId::generated_message_descriptor_data());
            messages.push(MoveStructTag::generated_message_descriptor_data());
            messages.push(Signature::generated_message_descriptor_data());
            messages.push(Ed25519Signature::generated_message_descriptor_data());
            messages.push(MultiEd25519Signature::generated_message_descriptor_data());
            messages.push(MultiAgentSignature::generated_message_descriptor_data());
            messages.push(AccountSignature::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(6);
            enums.push(transaction::TransactionType::generated_enum_descriptor_data());
            enums.push(write_set::WriteSetType::generated_enum_descriptor_data());
            enums.push(write_set_change::WriteSetChangeType::generated_enum_descriptor_data());
            enums.push(transaction_payload::PayloadType::generated_enum_descriptor_data());
            enums.push(signature::SignatureType::generated_enum_descriptor_data());
            enums.push(account_signature::AccountSignatureType::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
